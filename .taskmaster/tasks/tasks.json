{
  "master": {
    "tasks": [
      {
        "id": 44,
        "title": "Project Repository Initialization",
        "description": "Initialize the Git repository and set up the basic project directory structure as outlined in the PRD, including `functions/`, `public/`, `src/`, and root configuration files.",
        "details": "Create a new Git repository. Set up the initial folder structure: `functions/api/`, `public/`, `src/assets/`, `src/components/`, `src/lib/`, `src/pages/`. Create placeholder files like `functions/api/[[path]].ts`, `src/main.tsx`, `index.html`, `package.json`, `vite.config.ts`, `.dev.vars`, `.env`.",
        "testStrategy": "Verify that the project directory structure matches the PRD specification and all initial placeholder files are present.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Git Repository",
            "description": "Create a new Git repository in the project's root directory.",
            "dependencies": [],
            "details": "Execute 'git init' in the project's root directory.",
            "status": "done",
            "testStrategy": "Verify the existence of the '.git' directory in the project root."
          },
          {
            "id": 2,
            "title": "Establish Base Project Directories",
            "description": "Create the primary top-level directories for the project structure.",
            "dependencies": [
              1
            ],
            "details": "Create the 'functions/', 'public/', and 'src/' directories directly under the project root.",
            "status": "done",
            "testStrategy": "Confirm that 'functions/', 'public/', and 'src/' directories exist at the project root."
          },
          {
            "id": 3,
            "title": "Define Nested Source and API Directories",
            "description": "Create the specific subdirectories within the 'functions/' and 'src/' main directories.",
            "dependencies": [
              2
            ],
            "details": "Create 'functions/api/', 'src/assets/', 'src/components/', 'src/lib/', and 'src/pages/' directories.",
            "status": "done",
            "testStrategy": "Verify the existence of 'functions/api/', 'src/assets/', 'src/components/', 'src/lib/', and 'src/pages/' directories."
          },
          {
            "id": 4,
            "title": "Generate Root Configuration and Public Files",
            "description": "Create essential configuration files and the main HTML file at the project root.",
            "dependencies": [
              2
            ],
            "details": "Create empty placeholder files: 'package.json', 'vite.config.ts', 'index.html', '.dev.vars', and '.env' in the project root.",
            "status": "done",
            "testStrategy": "Check for the presence of 'package.json', 'vite.config.ts', 'index.html', '.dev.vars', and '.env' files in the project root."
          },
          {
            "id": 5,
            "title": "Populate Core Source and API Placeholder Files",
            "description": "Create the specified placeholder files within the 'functions/api/' and 'src/' directories.",
            "dependencies": [
              3
            ],
            "details": "Create empty placeholder files: 'functions/api/[[path]].ts' and 'src/main.tsx'.",
            "status": "done",
            "testStrategy": "Confirm the existence of 'functions/api/[[path]].ts' and 'src/main.tsx' in their respective paths."
          }
        ]
      },
      {
        "id": 45,
        "title": "Cloudflare Workers Project Setup",
        "description": "Set up a new project on Cloudflare Workers, linking it to the Git repository for continuous deployment. Configure the build settings for a React SPA with Cloudflare Workers for backend functions.",
        "status": "done",
        "dependencies": [
          44
        ],
        "priority": "high",
        "details": "Log in to Cloudflare and create a new Cloudflare Worker project. Connect it to the Git repository initialized in Task 44. Configure the `wrangler.toml` file for the project. Set the build command to `pnpm run build` and the output directory to `dist`. Ensure the Worker is configured to serve the React SPA and handle backend functions.",
        "testStrategy": "Successfully deploy the Worker project to Cloudflare. Verify that the build process completes without errors and the React SPA is accessible via the Worker's URL. Confirm that any basic Worker functions are also callable.",
        "subtasks": []
      },
      {
        "id": 46,
        "title": "Vite React Frontend Base Setup",
        "description": "Set up the frontend development environment using Vite and React with TypeScript. This includes configuring `vite.config.ts`, `package.json` dependencies, and the main React entry point.",
        "details": "In `package.json`, add `react`, `react-dom`, `typescript`, `@types/react`, `@types/react-dom`, `vite`, `@vitejs/plugin-react` as dependencies. Configure `vite.config.ts` to use the React plugin. Create `src/main.tsx` to render a basic React App component into `index.html`.",
        "testStrategy": "Run `npm install` and `npm run dev` (or equivalent Vite command). Verify that the React development server starts successfully and displays a basic React app in the browser.",
        "priority": "high",
        "dependencies": [
          44
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Vite Project and `package.json`",
            "description": "Create the project directory and initialize a new Vite project, which will scaffold the initial `package.json` and basic project structure.",
            "dependencies": [],
            "details": "Use `npm init vite@latest` or `yarn create vite` to scaffold a new React TypeScript project. This will create the project folder, `package.json`, `vite.config.ts`, `index.html`, and `src` directory.",
            "status": "done",
            "testStrategy": "Verify `package.json` exists in the root directory and contains basic Vite scripts like 'dev'."
          },
          {
            "id": 2,
            "title": "Install Core React and Vite Dependencies",
            "description": "Add all necessary React, React DOM, TypeScript, and Vite-related packages to the project's `package.json` and install them.",
            "dependencies": [
              1
            ],
            "details": "Add `react`, `react-dom`, `typescript`, `@types/react`, `@types/react-dom`, `vite`, `@vitejs/plugin-react` as dependencies. Run `npm install` or `yarn install`.",
            "status": "done",
            "testStrategy": "Check `package.json` for the presence of all specified dependencies and verify `node_modules` directory is populated."
          },
          {
            "id": 3,
            "title": "Configure `vite.config.ts` for React Plugin",
            "description": "Modify the `vite.config.ts` file to include and configure the `@vitejs/plugin-react` plugin, enabling React support.",
            "dependencies": [
              2
            ],
            "details": "Open `vite.config.ts` and import `react()` from `@vitejs/plugin-react`. Add `plugins: [react()]` to the `defineConfig` object.",
            "status": "done",
            "testStrategy": "Run `npm run dev` and check for any Vite configuration errors. The server should start without issues related to the React plugin."
          },
          {
            "id": 4,
            "title": "Create `src/main.tsx` with Basic React App",
            "description": "Develop the main TypeScript React entry point file (`src/main.tsx`) to render a simple React component.",
            "dependencies": [
              3
            ],
            "details": "Create `src/main.tsx`. Import `ReactDOM` from `react-dom/client` and `React` from `react`. Define a simple `App` functional component. Use `ReactDOM.createRoot(document.getElementById('root')!).render(<App />);` to render the component.",
            "status": "done",
            "testStrategy": "Ensure `src/main.tsx` compiles without TypeScript errors. A simple `console.log` inside the `App` component can be used to verify execution."
          },
          {
            "id": 5,
            "title": "Link `index.html` to `src/main.tsx`",
            "description": "Ensure the `index.html` file correctly references the `src/main.tsx` entry point and contains the root element for React to mount onto.",
            "dependencies": [
              4
            ],
            "details": "Verify `index.html` has `<div id=\"root\"></div>` and a script tag like `<script type=\"module\" src=\"/src/main.tsx\"></script>` in the `<body>` or `<head>`.",
            "status": "done",
            "testStrategy": "Run `npm run dev`. Open the browser to the development server URL. Verify that the basic React App component rendered from `main.tsx` is visible on the page."
          }
        ]
      },
      {
        "id": 47,
        "title": "Hono Backend Base Setup",
        "description": "Set up the backend API using Hono within Cloudflare Pages Functions. This involves configuring the `functions/api/[[path]].ts` entry point and adding Hono dependencies.",
        "details": "In `package.json`, add `hono` as a dependency. Create `functions/api/[[path]].ts` and initialize a basic Hono app: `import { Hono } from 'hono'; const app = new Hono(); app.get('/api/hello', (c) => c.text('Hello Hono!')); export const onRequest = app.fetch;`. This file will serve as the catch-all for `/api/*` requests.",
        "testStrategy": "Verify that the Hono app compiles without errors. After setting up `wrangler` (Task 48), confirm that the `/api/hello` endpoint is accessible locally.",
        "priority": "high",
        "dependencies": [
          44
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "Concurrently Local Dev Setup",
        "description": "Configure `concurrently` or a similar tool to run the Vite development server and the Cloudflare Wrangler local development server simultaneously for a seamless local development experience.",
        "details": "Install `concurrently` as a dev dependency. Add a script to `package.json` like `\"dev\": \"concurrently \\\"npm run dev:frontend\\\" \\\"npm run dev:backend\\\"\"`, where `dev:frontend` runs `vite` and `dev:backend` runs `wrangler pages dev public --compatibility-date=2023-10-26 --local-protocol=http --port 8787` (adjust port as needed). Ensure `wrangler` is installed globally or locally.",
        "testStrategy": "Run `npm run dev`. Verify that both the Vite frontend and Wrangler backend servers start up concurrently and are accessible on their respective ports.",
        "priority": "high",
        "dependencies": [
          46,
          47
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "Supabase Project & DB Setup",
        "description": "Set up a new Supabase project, including database creation and initial configuration for authentication services. Obtain necessary API keys and project URLs.",
        "details": "Go to Supabase.com, create a new project. Note down the Project URL and `anon` (public) key from the Project Settings -> API section. Familiarize with the SQL Editor for future schema creation.",
        "testStrategy": "Successfully create a Supabase project and confirm access to its dashboard, API keys, and SQL editor.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "Google Gemini API Key Acquisition",
        "description": "Obtain and configure access to the Google Gemini API for AI-powered story and illustration generation.",
        "details": "Access the Google Cloud Console or AI Studio. Enable the Gemini API. Create an API key for server-side use. Ensure billing is enabled if required.",
        "testStrategy": "Successfully generate a Google Gemini API key and confirm its validity (e.g., by making a test call with a tool like Postman or curl).",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "Environment Variable Management Strategy",
        "description": "Establish a robust environment variable management strategy for both local development (`.env`, `.dev.vars`) and production (Cloudflare Pages console).",
        "details": "For frontend, define `VITE_SUPABASE_URL`, `VITE_SUPABASE_ANON_KEY` in `.env`. For backend, define `SUPABASE_URL`, `SUPABASE_SERVICE_ROLE_KEY` (or `SUPABASE_ANON_KEY` if service role not needed yet), `GEMINI_API_KEY` in `.dev.vars`. Document the process for setting these variables in the Cloudflare Pages console for production.",
        "testStrategy": "Verify that environment variables are correctly loaded and accessible in both frontend (via `import.meta.env`) and backend (via `c.env` in Hono) during local development. Confirm the process for setting them in Cloudflare Pages.",
        "priority": "high",
        "dependencies": [
          45,
          49,
          50
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "Vite Proxy Configuration for API",
        "description": "Configure Vite's development server to proxy API requests from the frontend to the locally running Hono backend, ensuring seamless communication during development.",
        "details": "In `vite.config.ts`, add a `server.proxy` configuration: `server: { proxy: { '/api': { target: 'http://localhost:8787', changeOrigin: true, rewrite: (path) => path.replace(/^\\/api/, '/api') } } }`. Ensure the target port matches the Wrangler dev server port.",
        "testStrategy": "Start both frontend and backend servers using `npm run dev`. Make a fetch request from the frontend to `/api/hello`. Verify that the request is successfully proxied to the backend and the 'Hello Hono!' response is received.",
        "priority": "high",
        "dependencies": [
          46,
          47,
          48
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 53,
        "title": "React Router Implementation",
        "description": "Implement React Router for client-side routing, defining basic routes for authentication (login, signup) and content display (stories).",
        "details": "Install `react-router-dom`. In `src/main.tsx` or a dedicated `App.tsx`, set up `BrowserRouter`. Define routes for `/login`, `/signup`, and `/stories` using `Routes` and `Route` components. Create placeholder components for each route.",
        "testStrategy": "Navigate to `/login`, `/signup`, and `/stories` in the browser. Verify that the correct placeholder components are rendered for each route without full page reloads.",
        "priority": "medium",
        "dependencies": [
          46
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install React Router DOM Package",
            "description": "Install the `react-router-dom` package as a project dependency to enable client-side routing capabilities within the React application.",
            "dependencies": [],
            "details": "Execute `npm install react-router-dom` or `yarn add react-router-dom` in your project's root directory. This will add the necessary library to your `node_modules` and update `package.json`.",
            "status": "done",
            "testStrategy": "Verify that `react-router-dom` is listed under `dependencies` in your `package.json` file after installation."
          },
          {
            "id": 2,
            "title": "Create Placeholder Route Components",
            "description": "Develop basic functional components that will serve as placeholders for the `/login`, `/signup`, and `/stories` routes. These components will initially render simple text to confirm routing functionality.",
            "dependencies": [],
            "details": "Create a `components/` directory (if it doesn't exist) in `src/`. Inside, create three new files: `LoginPage.tsx`, `SignupPage.tsx`, and `StoriesPage.tsx`. Each file should export a simple functional component, e.g., `const LoginPage = () => <div>Login Page</div>; export default LoginPage;`.",
            "status": "done",
            "testStrategy": "Confirm the creation of the three new component files and ensure they contain valid, basic React functional component exports."
          },
          {
            "id": 3,
            "title": "Configure BrowserRouter in Main Application",
            "description": "Integrate `BrowserRouter` into the root of the React application to provide the routing context. This typically involves wrapping the main `App` component.",
            "dependencies": [
              1
            ],
            "details": "Open `src/main.tsx` (or `src/App.tsx` if `main.tsx` directly renders `App`). Import `BrowserRouter` from `react-router-dom`. Wrap the `<App />` component with `<BrowserRouter>...</BrowserRouter>`. For example: `ReactDOM.createRoot(document.getElementById('root')!).render(<React.StrictMode><BrowserRouter><App /></BrowserRouter></React.StrictMode>);`.",
            "status": "done",
            "testStrategy": "Ensure the application compiles successfully without any errors related to `BrowserRouter` or `react-router-dom` imports."
          },
          {
            "id": 4,
            "title": "Define Routes for Authentication and Content Display",
            "description": "Implement the `Routes` and `Route` components within the main application's structure to map specific URL paths (`/login`, `/signup`, `/stories`) to their corresponding placeholder components.",
            "dependencies": [
              2,
              3
            ],
            "details": "In `src/App.tsx` (or the component wrapped by `BrowserRouter`), import `Routes` and `Route` from `react-router-dom`, along with the `LoginPage`, `SignupPage`, and `StoriesPage` components. Inside the `App` component's return statement, use `<Routes>` to enclose the individual `<Route>` definitions: `<Routes><Route path=\"/login\" element={<LoginPage />} /><Route path=\"/signup\" element={<SignupPage />} /><Route path=\"/stories\" element={<StoriesPage />} /></Routes>`. Consider adding a default route for `/` if desired.",
            "status": "done",
            "testStrategy": "Verify that the application compiles without errors after defining the routes. No visual changes are expected at this stage, as navigation is not yet implemented."
          },
          {
            "id": 5,
            "title": "Verify Router Functionality and Navigation",
            "description": "Manually test the implemented routes by directly navigating to each defined path in the browser's address bar to confirm that the correct placeholder component is rendered for each route.",
            "dependencies": [
              4
            ],
            "details": "Start the development server (`npm run dev` or `yarn dev`). Open your application in a web browser. In the browser's address bar, manually type and navigate to `http://localhost:<port>/login`, `http://localhost:<port>/signup`, and `http://localhost:<port>/stories`. For each URL, observe that the corresponding placeholder text (e.g., 'Login Page', 'Signup Page', 'Stories Page') is displayed on the screen.",
            "status": "done",
            "testStrategy": "Visually confirm that navigating to each specified URL path renders the expected placeholder content. Check the browser's developer console for any routing-related errors or warnings during navigation."
          }
        ]
      },
      {
        "id": 54,
        "title": "shadcn/ui Integration",
        "description": "Integrate `shadcn/ui` into the React frontend project, following its setup instructions to enable easy component generation and styling.",
        "details": "Follow the `shadcn/ui` installation guide, which typically involves running `npx shadcn-ui@latest init` and configuring `tailwind.config.js`, `components.json`, and `globals.css`. Add a simple `Button` component to verify the setup.",
        "testStrategy": "Successfully install `shadcn/ui`. Add a `shadcn/ui` component (e.g., Button) to a React page and verify it renders correctly with the applied styles.",
        "priority": "medium",
        "dependencies": [
          46
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize shadcn/ui Project",
            "description": "Run the `shadcn/ui` initialization command to set up the basic configuration files and directory structure.",
            "dependencies": [],
            "details": "Execute `npx shadcn-ui@latest init` in the project root. Follow the prompts, selecting appropriate options for TypeScript, style (e.g., 'default' or 'new-york'), base color, and CSS variables. This command will create or modify `components.json`, `tailwind.config.js`, and `globals.css`.",
            "status": "done",
            "testStrategy": "Verify that `components.json` is created, `tailwind.config.js` is updated, and `globals.css` has new imports/variables."
          },
          {
            "id": 2,
            "title": "Configure Tailwind CSS and Global Styles",
            "description": "Adjust `tailwind.config.js` and `globals.css` to ensure `shadcn/ui` styles are correctly applied and base styles are imported.",
            "dependencies": [
              1
            ],
            "details": "Open `tailwind.config.js` and ensure the `content` array correctly includes paths to your components (e.g., `./app/**/*.{js,ts,jsx,tsx}`, `./components/**/*.{js,ts,jsx,tsx}`). Verify that the `presets` array includes `[@shadcn/ui/tailwind]` and the `theme` object is correctly extended. In `globals.css`, ensure the `shadcn/ui` CSS variables are imported, typically at the top of the file (e.g., `@import './styles/base.css'; @import './styles/theme.css';` or similar, depending on the init output).",
            "status": "done",
            "testStrategy": "Run the development server (`npm run dev`). No visual changes expected yet, but ensure no compilation errors related to Tailwind or CSS imports."
          },
          {
            "id": 3,
            "title": "Verify `components.json` and Utility Files",
            "description": "Confirm that `components.json` is correctly configured and essential utility files like `lib/utils.ts` are present and functional.",
            "dependencies": [
              2
            ],
            "details": "Review `components.json` to ensure `style`, `rsc`, `tailwind.config`, `tailwind.css`, `tailwind.baseColor`, `tailwind.cssVariables`, `prefix`, and `ui` properties are correctly set, especially `ui` pointing to the `components/ui` directory. Verify that `lib/utils.ts` (or similar path) exists and exports the `cn` utility function, which is crucial for `shadcn/ui` component styling.",
            "status": "done",
            "testStrategy": "Check the contents of `components.json` and `lib/utils.ts` manually. Ensure the `components/ui` directory is created and empty, ready for components."
          },
          {
            "id": 4,
            "title": "Add and Render a Sample Component (Button)",
            "description": "Add a simple `Button` component using the `shadcn/ui` CLI and integrate it into a test page or component to verify the setup.",
            "dependencies": [
              3
            ],
            "details": "Run `npx shadcn-ui@latest add button` to generate the `Button` component files in `components/ui`. Then, import the `Button` component into a relevant page or a new temporary test component (e.g., `app/page.tsx` or `src/App.tsx`) and render it. For example: `<Button>Click Me</Button>`.",
            "status": "done",
            "testStrategy": "Start the development server (`npm run dev`). Navigate to the page where the `Button` component is rendered. Visually confirm that the `Button` is styled correctly according to `shadcn/ui`'s default appearance (e.g., rounded corners, appropriate colors, hover effects). Click the button to ensure no console errors."
          },
          {
            "id": 5,
            "title": "Finalize Integration and Document Setup",
            "description": "Remove any temporary test code and add a brief note to the project's documentation (e.g., README) regarding the `shadcn/ui` integration.",
            "dependencies": [
              4
            ],
            "details": "Remove the temporary `Button` component usage from the test page/component (unless it's intended to be a permanent part of the UI). Add a section to the project's `README.md` or a dedicated `docs` file explaining that `shadcn/ui` has been integrated, how to add new components (e.g., `npx shadcn-ui@latest add <component-name>`), and any specific configuration choices made during setup.",
            "status": "done",
            "testStrategy": "Verify that the temporary test code has been removed. Check the `README.md` or documentation for the new `shadcn/ui` integration notes. Ensure the project still builds and runs without issues after cleanup."
          }
        ]
      },
      {
        "id": 55,
        "title": "Global State Management Setup (Zustand)",
        "description": "Set up global state management using Zustand (or React Context) to manage application-wide states, particularly user authentication status and tokens.",
        "details": "Install `zustand`. Create a store (e.g., `src/lib/stores/authStore.ts`) to hold `user` object, `token`, and actions like `login`, `logout`, `setToken`. Initialize the store with default values. Consider using `localStorage` for token persistence.",
        "testStrategy": "Create a simple component that uses the Zustand store to display a dummy user status. Verify that the state can be updated and read from different components.",
        "priority": "medium",
        "dependencies": [
          46
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Zustand and Create Initial Auth Store File",
            "description": "Install the `zustand` package and create the foundational file for the authentication store.",
            "dependencies": [],
            "details": "Run `npm install zustand` or `yarn add zustand`. Create `src/lib/stores/authStore.ts` (or `src/stores/authStore.ts` based on project structure). Export a basic `create` function from `zustand` to initialize an empty store.",
            "status": "done",
            "testStrategy": "Verify `zustand` is listed in `package.json`. Confirm `authStore.ts` file exists in the specified path."
          },
          {
            "id": 2,
            "title": "Define Authentication State and Actions",
            "description": "Define the core state variables (`user`, `token`) and the `login`, `logout`, `setToken` actions within the `authStore`.",
            "dependencies": [
              1
            ],
            "details": "Inside `src/lib/stores/authStore.ts`, use `create` to define the initial state: `user: null`, `token: null`. Implement actions: `login(user, token)` (sets `user` and `token`), `logout()` (resets `user` and `token` to `null`), `setToken(token)` (updates only the `token`). Ensure actions correctly use `set` to update the state.",
            "status": "done",
            "testStrategy": "Write simple unit tests for `authStore.ts` to verify state changes after calling `login`, `logout`, and `setToken` actions. Assert that the state reflects the expected values."
          },
          {
            "id": 3,
            "title": "Implement Token Persistence with LocalStorage",
            "description": "Enhance the `authStore` to persist the authentication token in `localStorage` and retrieve it upon store initialization.",
            "dependencies": [
              2
            ],
            "details": "Modify `authStore.ts`: When `login` or `setToken` is called, save the token to `localStorage` (e.g., `localStorage.setItem('authToken', token)`). When `logout` is called, remove the token from `localStorage` (`localStorage.removeItem('authToken')`). Initialize the store's `token` state by attempting to read from `localStorage` first (e.g., `token: typeof window !== 'undefined' ? localStorage.getItem('authToken') : null`).",
            "status": "done",
            "testStrategy": "Manually test by logging in, closing/reopening the browser tab, and verifying the user remains logged in. Inspect `localStorage` in browser developer tools to confirm token presence/absence."
          },
          {
            "id": 4,
            "title": "Integrate and Consume Auth Store in a Component",
            "description": "Demonstrate the usage of the `authStore` by integrating it into a sample React component to display authentication status and trigger actions.",
            "dependencies": [
              3
            ],
            "details": "Create a simple component (e.g., `AuthStatus.tsx` or modify an existing `App.tsx`): Import `useAuthStore` from `authStore.ts`. Use `const { user, token, login, logout } = useAuthStore();` to access state and actions. Display `user.name` or 'Guest' based on `user` state. Add buttons to call `login` (with dummy data like `{ name: 'Test User' }` and a dummy token) and `logout` actions.",
            "status": "done",
            "testStrategy": "Manually test the component: click login/logout buttons and observe the UI changes (e.g., user name displayed/hidden) and verify `localStorage` updates accordingly."
          },
          {
            "id": 5,
            "title": "Add Basic Type Safety and Refinements",
            "description": "Enhance the `authStore` with basic TypeScript type definitions for the state and actions to improve code robustness and maintainability.",
            "dependencies": [
              4
            ],
            "details": "Define TypeScript interfaces for the `User` object (e.g., `interface User { id: string; name: string; email: string; }`) and the `AuthStore` state/actions (e.g., `interface AuthState { user: User | null; token: string | null; login: (user: User, token: string) => void; logout: () => void; setToken: (token: string) => void; }`). Apply these types to the `create` function and its arguments/return values in `authStore.ts`.",
            "status": "done",
            "testStrategy": "Verify that TypeScript compilation passes without errors. Attempt to pass incorrect types to `login` or `setToken` actions in the consuming component to ensure TypeScript catches the type mismatches during development."
          }
        ]
      },
      {
        "id": 56,
        "title": "Basic Layout Components",
        "description": "Develop basic layout components such as a header, footer, and a main content wrapper to provide a consistent UI structure across the application.",
        "details": "Create `src/components/layout/Header.tsx`, `src/components/layout/Footer.tsx`, and `src/components/layout/MainLayout.tsx`. Use `shadcn/ui` components where appropriate (e.g., `Button` for navigation, `Card` for sections). Integrate these into the main `App.tsx` or `Root` component.",
        "testStrategy": "Render the layout components on a test page. Verify that they appear correctly and provide a basic visual structure. Ensure navigation links (if added) work with React Router.",
        "priority": "medium",
        "dependencies": [
          53,
          54
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Establish Layout Component Directory",
            "description": "Create the necessary directory structure for layout components within `src/components` to ensure a clean and organized codebase.",
            "dependencies": [],
            "details": "Create the directory `src/components/layout`. This will house `Header.tsx`, `Footer.tsx`, and `MainLayout.tsx`.",
            "status": "done",
            "testStrategy": "Verify the directory `src/components/layout` exists in the project structure."
          },
          {
            "id": 2,
            "title": "Develop Header Component",
            "description": "Implement the `Header` component, including a basic application title/logo and placeholder navigation links, utilizing `shadcn/ui` components for styling and functionality.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/layout/Header.tsx`. Use a semantic `<header>` tag. Incorporate `shadcn/ui` components like `Button` for navigation items (e.g., Home, About, Contact) and a simple `div` or `h1` for the application title. Ensure basic styling for alignment and spacing.",
            "status": "done",
            "testStrategy": "Render `Header` in isolation (e.g., in Storybook or a temporary test page) and visually confirm title and navigation links are present and styled correctly."
          },
          {
            "id": 3,
            "title": "Develop Footer Component",
            "description": "Implement the `Footer` component, including copyright information and potentially placeholder links, leveraging `shadcn/ui` components where appropriate.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/layout/Footer.tsx`. Use a semantic `<footer>` tag. Include copyright text (e.g., '© 2023 Your App Name'). Optionally, add placeholder links using `shadcn/ui` `Button` or simple `<a>` tags. Ensure basic styling for alignment and spacing.",
            "status": "done",
            "testStrategy": "Render `Footer` in isolation and visually confirm copyright information and any placeholder links are present and styled correctly."
          },
          {
            "id": 4,
            "title": "Develop MainLayout Wrapper Component",
            "description": "Create the `MainLayout` component that acts as a central wrapper, integrating the `Header` and `Footer` components and providing a designated area for main content via its children prop.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create `src/components/layout/MainLayout.tsx`. This component should accept `children` as a React prop. It will render the `Header` component, followed by a `main` HTML element containing `{children}`, and finally the `Footer` component. Apply basic flexbox or grid styling to ensure the header, main content, and footer are vertically stacked.",
            "status": "done",
            "testStrategy": "Create a temporary test page that uses `MainLayout` and passes some dummy content as children. Verify that the Header, dummy content, and Footer are all rendered in the correct order."
          },
          {
            "id": 5,
            "title": "Integrate MainLayout into Application Entry Point",
            "description": "Modify the main application entry point (e.g., `App.tsx` or `main.tsx`'s root component) to utilize the `MainLayout` component, thereby applying the consistent UI structure across the entire application.",
            "dependencies": [
              4
            ],
            "details": "Locate the primary application component (e.g., `App.tsx` or the component rendered by `ReactDOM.createRoot` in `main.tsx`). Import `MainLayout` and wrap the existing application content (e.g., your `Router` or main application routes) with the `MainLayout` component.",
            "status": "done",
            "testStrategy": "Run the application and visually inspect the main page. Confirm that the Header and Footer are consistently displayed at the top and bottom, respectively, and that the main application content renders correctly in between."
          }
        ]
      },
      {
        "id": 57,
        "title": "Hono API Route Structure (`/api/*`)",
        "description": "Define the base routing structure for the Hono API, ensuring that all API endpoints are prefixed with `/api/*` as per the PRD.",
        "details": "In `functions/api/[[path]].ts`, ensure the Hono app is configured to handle routes under `/api/`. For example, `app.route('/api/auth', authRoutes); app.route('/api/stories', storyRoutes);`. Create separate Hono instances for different logical groups of API endpoints (e.g., `authRoutes`, `storyRoutes`).",
        "testStrategy": "Create a dummy route like `/api/test` and verify that it can be accessed successfully through the Cloudflare Pages Functions setup (locally via Wrangler and after deployment).",
        "priority": "high",
        "dependencies": [
          47
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Hono App and Base `/api` Route in `functions/api/[[path]].ts`",
            "description": "Set up the main Hono application instance within `functions/api/[[path]].ts` and configure it to serve as the entry point for all `/api/*` routes, leveraging Cloudflare Pages Functions' catch-all routing.",
            "dependencies": [],
            "details": "In `functions/api/[[path]].ts`, import `Hono` from 'hono' and create `const app = new Hono();`. Ensure the file exports `app.fetch` as the default handler. This file will implicitly handle all requests under the `/api/` path due to its `[[path]]` naming convention.",
            "status": "done",
            "testStrategy": "N/A (initial setup, no direct testable endpoint yet)"
          },
          {
            "id": 2,
            "title": "Create `authRoutes` Hono Instance for Authentication Endpoints",
            "description": "Create a new, separate Hono instance specifically for authentication-related API endpoints. This instance will encapsulate routes like `/login`, `/register`, etc., which will eventually be mounted under `/api/auth`.",
            "dependencies": [
              1
            ],
            "details": "Create a new file, e.g., `functions/api/authRoutes.ts`. Inside this file, import `Hono` and create `const authRoutes = new Hono();`. Export `authRoutes` as the default. For now, add a placeholder route like `authRoutes.get('/test', (c) => c.text('Auth test endpoint'));` to confirm it's a valid Hono instance.",
            "status": "done",
            "testStrategy": "N/A (not yet integrated into the main app)"
          },
          {
            "id": 3,
            "title": "Create `storyRoutes` Hono Instance for Story Management Endpoints",
            "description": "Create another new, separate Hono instance specifically for story management-related API endpoints. This instance will encapsulate routes like `/create`, `/:id`, etc., which will eventually be mounted under `/api/stories`.",
            "dependencies": [
              1
            ],
            "details": "Create a new file, e.g., `functions/api/storyRoutes.ts`. Inside this file, import `Hono` and create `const storyRoutes = new Hono();`. Export `storyRoutes` as the default. For now, add a placeholder route like `storyRoutes.get('/test', (c) => c.text('Stories test endpoint'));` to confirm it's a valid Hono instance.",
            "status": "done",
            "testStrategy": "N/A (not yet integrated into the main app)"
          },
          {
            "id": 4,
            "title": "Integrate `authRoutes` and `storyRoutes` into Main API App",
            "description": "Import the `authRoutes` and `storyRoutes` Hono instances into `functions/api/[[path]].ts` and mount them under their respective `/auth` and `/stories` base paths using `app.route()`, ensuring they are accessible via `/api/auth/*` and `/api/stories/*`.",
            "dependencies": [
              2,
              3
            ],
            "details": "In `functions/api/[[path]].ts`, import `authRoutes` from './authRoutes' and `storyRoutes` from './storyRoutes'. Then, add `app.route('/auth', authRoutes);` and `app.route('/stories', storyRoutes);` to the main `app` instance. The `[[path]].ts` file handles the `/api` prefix, so `app.route('/auth', ...)` correctly maps to `/api/auth`.",
            "status": "done",
            "testStrategy": "N/A (full verification in the next step)"
          },
          {
            "id": 5,
            "title": "Add Basic Test Endpoints and Verify API Routing Structure",
            "description": "Implement simple GET endpoints within each sub-route (`authRoutes`, `storyRoutes`) and a root `/api` endpoint to confirm that the overall routing structure is correctly set up and accessible as per the PRD.",
            "dependencies": [
              4
            ],
            "details": "1. In `functions/api/[[path]].ts`, add `app.get('/', (c) => c.text('Hono API Root Operational'));`.\n2. In `functions/api/authRoutes.ts`, change the placeholder to `authRoutes.get('/status', (c) => c.text('Auth API operational'));`.\n3. In `functions/api/storyRoutes.ts`, change the placeholder to `storyRoutes.get('/status', (c) => c.text('Stories API operational'));`.",
            "status": "done",
            "testStrategy": "Deploy the application (e.g., to a local development server or a staging environment). Use `curl` or a browser to hit the following endpoints and verify responses:\n- `GET /api` (should return 'Hono API Root Operational')\n- `GET /api/auth/status` (should return 'Auth API operational')\n- `GET /api/stories/status` (should return 'Stories API operational')\n- Verify that requests to non-existent paths (e.g., `/api/nonexistent` or `/api/auth/nonexistent`) return a 404 Not Found response."
          }
        ]
      },
      {
        "id": 58,
        "title": "Supabase Client Integration (Backend)",
        "description": "Integrate the Supabase client library into the Hono backend to enable database interactions and authentication services.",
        "details": "Install `@supabase/supabase-js`. In the Hono app, create a Supabase client instance using environment variables (`SUPABASE_URL`, `SUPABASE_SERVICE_ROLE_KEY` or `SUPABASE_ANON_KEY`). Make sure to pass the client instance to route handlers or use it directly within them. Example: `import { createClient } from '@supabase/supabase-js'; const supabase = createClient(c.env.SUPABASE_URL, c.env.SUPABASE_SERVICE_ROLE_KEY);`.",
        "testStrategy": "Write a simple Hono endpoint (e.g., `/api/test-db`) that attempts to fetch data from a non-existent or dummy Supabase table. Verify that the Supabase client initializes without errors and can attempt database operations.",
        "priority": "high",
        "dependencies": [
          49,
          51,
          57
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 59,
        "title": "Google Gemini Client Integration (Backend)",
        "description": "Integrate the Google Gemini API client library into the Hono backend to facilitate AI-powered content generation.",
        "details": "Install the appropriate Google Gemini client library (e.g., `@google/generative-ai`). Initialize the client with the `GEMINI_API_KEY` from environment variables. Create a helper function or service to encapsulate Gemini API calls.",
        "testStrategy": "Create a simple Hono endpoint (e.g., `/api/test-gemini`) that makes a basic text generation request to the Gemini API. Verify that the API call is successful and returns a response.",
        "priority": "high",
        "dependencies": [
          50,
          51,
          57
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Google Gemini Client Library and Configure Environment Variable",
            "description": "Add the `@google/generative-ai` package to the project dependencies and ensure the `GEMINI_API_KEY` environment variable is correctly configured for both local development and deployment environments.",
            "dependencies": [],
            "details": "Execute `npm install @google/generative-ai` or `yarn add @google/generative-ai`. For local development, add `GEMINI_API_KEY=your_api_key_here` to your `.env` file. Ensure this variable is securely managed in production environments (e.g., via CI/CD secrets or cloud provider configurations).",
            "status": "done",
            "testStrategy": "Verify `package.json` contains `@google/generative-ai` as a dependency. Create a temporary script to `console.log(process.env.GEMINI_API_KEY)` to confirm it's accessible."
          },
          {
            "id": 2,
            "title": "Develop Gemini Client Initialization Module",
            "description": "Create a dedicated utility module (e.g., `src/lib/geminiClient.ts`) responsible for initializing and exporting a `GoogleGenerativeAI` client instance using the `GEMINI_API_KEY`.",
            "dependencies": [
              1
            ],
            "details": "Import `GoogleGenerativeAI` from `@google/generative-ai`. Create a new instance: `new GoogleGenerativeAI(process.env.GEMINI_API_KEY!)`. Export this initialized client. Implement a check to throw an error if `GEMINI_API_KEY` is not found, providing a clear message.",
            "status": "done",
            "testStrategy": "Create a simple unit test that imports the `geminiClient` module and asserts that the exported client instance is not null/undefined. Optionally, test the error handling for a missing API key."
          },
          {
            "id": 3,
            "title": "Implement Generic Gemini Content Generation Helper Function",
            "description": "Create a reusable asynchronous helper function (e.g., `generateTextContent` in `src/services/geminiService.ts`) that takes a prompt string, utilizes the initialized Gemini client, and calls the `generateContent` method to retrieve AI-generated text.",
            "dependencies": [
              2
            ],
            "details": "This function should accept a string `prompt` as an argument. Use the `getGenerativeModel({ model: 'gemini-pro' })` method from the initialized client. Call `model.generateContent(prompt)` and extract the text from the response. Include basic `try-catch` for API call failures, logging errors.",
            "status": "done",
            "testStrategy": "Mock the `GoogleGenerativeAI` client and its `generateContent` method. Write a unit test for `generateTextContent` to ensure it correctly calls the mocked API with the given prompt and returns the expected text."
          },
          {
            "id": 4,
            "title": "Integrate Gemini Helper into Hono Backend Endpoint",
            "description": "Create a new Hono POST route (e.g., `/api/generate-content`) that accepts a JSON body containing a `prompt` field, calls the `generateTextContent` helper function, and returns the AI-generated response.",
            "dependencies": [
              3
            ],
            "details": "Define a new Hono route handler. Parse the request body to extract the `prompt`. Call the `generateTextContent` helper with the prompt. Send the returned AI-generated text as a JSON response. Ensure appropriate HTTP status codes (e.g., 200 for success, 400 for bad request if prompt is missing).",
            "status": "done",
            "testStrategy": "Use an API testing tool (e.g., Postman, Insomnia) or write an integration test to send a POST request to `/api/generate-content` with a sample prompt. Verify that the endpoint returns a 200 OK status and a non-empty string as the generated content."
          },
          {
            "id": 5,
            "title": "Implement Robust Error Handling and Response Formatting",
            "description": "Enhance the Gemini integration by adding comprehensive error handling for various API responses (e.g., rate limits, invalid requests, internal errors) and ensure the generated content is consistently formatted before being sent to the client.",
            "dependencies": [
              4
            ],
            "details": "Refine the `try-catch` blocks in the `generateTextContent` helper and the Hono route. Map specific Gemini API errors (e.g., `429 RESOURCE_EXHAUSTED` for rate limits, `400 INVALID_ARGUMENT` for bad prompts) to appropriate HTTP status codes and user-friendly error messages. Implement post-processing on the generated text (e.g., trimming whitespace, removing unwanted characters, handling potential markdown formatting if not desired).",
            "status": "done",
            "testStrategy": "Simulate different error scenarios (e.g., by mocking the Gemini API to return error codes like 429, 500, or malformed responses) and verify that the Hono endpoint returns the correct HTTP status codes and informative error messages. Test with various prompt outputs to ensure consistent and clean text formatting."
          }
        ]
      },
      {
        "id": 60,
        "title": "Backend Auth Endpoints",
        "description": "Implement backend API endpoints for user signup (`/api/auth/signup`) and login (`/api/auth/login`) using Hono.",
        "details": "Create `functions/api/auth.ts` to define Hono routes for `/signup` and `/login`. These routes will receive user credentials (email, password) from the frontend. Use `c.req.json()` to parse the request body.",
        "testStrategy": "Use a tool like Postman or `curl` to send POST requests to `/api/auth/signup` and `/api/auth/login` with dummy data. Verify that the endpoints receive the data correctly and return a placeholder success/error response.",
        "priority": "high",
        "dependencies": [
          57,
          58
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Hono Auth Router",
            "description": "Create the `functions/api/auth.ts` file and initialize a new Hono router instance specifically for authentication routes. Export this router for use in the main application.",
            "dependencies": [],
            "details": "Create `functions/api/auth.ts`. Import `Hono` and instantiate `const auth = new Hono();`. Export `auth` as default or named export.",
            "status": "done",
            "testStrategy": "Verify `functions/api/auth.ts` exists and exports a Hono instance."
          },
          {
            "id": 2,
            "title": "Implement Signup Endpoint Skeleton",
            "description": "Define the POST route for `/signup` within the `auth` router. Implement basic request body parsing using `c.req.json()` to extract email and password, and return a placeholder success response.",
            "dependencies": [
              1
            ],
            "details": "Inside `functions/api/auth.ts`, add `auth.post('/signup', async (c) => { const body = await c.req.json(); const { email, password } = body; return c.json({ message: 'Signup endpoint hit', email, password }); });`",
            "status": "done",
            "testStrategy": "Use a tool like Postman/Insomnia or `curl` to send a POST request to `/api/auth/signup` (once integrated) with a JSON body containing email and password, and verify the placeholder response."
          },
          {
            "id": 3,
            "title": "Implement Login Endpoint Skeleton",
            "description": "Define the POST route for `/login` within the `auth` router. Implement basic request body parsing using `c.req.json()` to extract email and password, and return a placeholder success response.",
            "dependencies": [
              1
            ],
            "details": "Inside `functions/api/auth.ts`, add `auth.post('/login', async (c) => { const body = await c.req.json(); const { email, password } = body; return c.json({ message: 'Login endpoint hit', email, password }); });`",
            "status": "done",
            "testStrategy": "Use a tool like Postman/Insomnia or `curl` to send a POST request to `/api/auth/login` (once integrated) with a JSON body containing email and password, and verify the placeholder response."
          },
          {
            "id": 4,
            "title": "Integrate Auth Router into Main Hono App",
            "description": "Import the `auth` router into the main Hono application file (e.g., `functions/api/index.ts`) and mount it under the `/api/auth` path.",
            "dependencies": [
              2,
              3
            ],
            "details": "In `functions/api/index.ts` (or your main Hono app file), import `auth` from `./auth`. Then, add `app.route('/api/auth', auth);` to mount the auth router.",
            "status": "done",
            "testStrategy": "Run the application and attempt to access `/api/auth/signup` and `/api/auth/login` endpoints. Verify that the placeholder responses from subtasks 2 and 3 are returned, indicating successful routing."
          },
          {
            "id": 5,
            "title": "Add Basic Request Body Validation",
            "description": "Enhance both the `/signup` and `/login` endpoints to perform basic validation, ensuring that `email` and `password` are present in the request body. Return a 400 Bad Request response if either is missing.",
            "dependencies": [
              2,
              3
            ],
            "details": "Modify the `auth.post('/signup', ...)` and `auth.post('/login', ...)` handlers. After parsing `body`, add checks: `if (!email || !password) { return c.json({ error: 'Email and password are required' }, 400); }`",
            "status": "done",
            "testStrategy": "Send POST requests to `/api/auth/signup` and `/api/auth/login` with missing `email`, missing `password`, or both. Verify that a 400 status code and an appropriate error message are returned."
          }
        ]
      },
      {
        "id": 61,
        "title": "Supabase User Authentication Logic (Backend)",
        "description": "Implement the logic within the backend authentication endpoints to interact with Supabase for user registration and login.",
        "details": "For signup, use `supabase.auth.signUp({ email, password })`. For login, use `supabase.auth.signInWithPassword({ email, password })`. Handle success and error responses from Supabase, returning appropriate HTTP status codes and messages.",
        "testStrategy": "Attempt to sign up a new user and log in an existing user via the API endpoints. Verify that users are created/authenticated in the Supabase dashboard and the API returns success or specific error messages (e.g., 'User already exists', 'Invalid credentials').",
        "priority": "high",
        "dependencies": [
          60
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Supabase Client in Backend",
            "description": "Initialize and configure the Supabase client within the backend application, ensuring it can connect to the Supabase project and is accessible for authentication operations. This includes setting up environment variables for Supabase URL and Anon Key.",
            "dependencies": [],
            "details": "Ensure `supabase-js` or equivalent SDK is installed and correctly imported. Configure the client with `process.env.SUPABASE_URL` and `process.env.SUPABASE_ANON_KEY`.",
            "status": "done",
            "testStrategy": "Write a simple test to verify the Supabase client instance is successfully created and can perform a basic (e.g., non-auth) query or just check if the client object is instantiated correctly."
          },
          {
            "id": 2,
            "title": "Implement User Registration Endpoint Core Logic",
            "description": "Develop the backend logic for the user registration endpoint. This involves receiving `email` and `password` from the request body and calling `supabase.auth.signUp({ email, password })`.",
            "dependencies": [
              1
            ],
            "details": "Create an API route (e.g., `/auth/signup`) that accepts POST requests. Extract `email` and `password` from the request body. Call `supabase.auth.signUp` and capture its raw response (data, error).",
            "status": "done",
            "testStrategy": "Use a tool like Postman or write an integration test to send a POST request to the `/auth/signup` endpoint with valid email/password and verify that Supabase receives the request (e.g., by checking Supabase logs or a mock)."
          },
          {
            "id": 3,
            "title": "Implement User Login Endpoint Core Logic",
            "description": "Develop the backend logic for the user login endpoint. This involves receiving `email` and `password` from the request body and calling `supabase.auth.signInWithPassword({ email, password })`.",
            "dependencies": [
              1
            ],
            "details": "Create an API route (e.g., `/auth/login`) that accepts POST requests. Extract `email` and `password` from the request body. Call `supabase.auth.signInWithPassword` and capture its raw response (data, error).",
            "status": "done",
            "testStrategy": "Use a tool like Postman or write an integration test to send a POST request to the `/auth/login` endpoint with valid email/password and verify that Supabase receives the request."
          },
          {
            "id": 4,
            "title": "Handle Supabase Registration Responses and Errors",
            "description": "Implement robust error handling and success response formatting for the user registration endpoint. This includes parsing the `data` and `error` objects returned by `supabase.auth.signUp` and returning appropriate HTTP status codes (e.g., 200 OK, 400 Bad Request, 409 Conflict) and user-friendly messages.",
            "dependencies": [
              2
            ],
            "details": "For success, return 200 OK with relevant user/session data (if applicable and safe to expose). For errors, identify common Supabase errors (e.g., `User already registered`, `Invalid email format`) and map them to specific HTTP status codes (e.g., 409 for conflict, 400 for bad input) and descriptive error messages. Implement a generic 500 for unexpected errors.",
            "status": "done",
            "testStrategy": "Write unit/integration tests for the registration endpoint: Test with valid credentials (expect 200 OK). Test with an already registered email (expect 409 Conflict). Test with invalid email format (expect 400 Bad Request). Test with missing credentials (expect 400 Bad Request)."
          },
          {
            "id": 5,
            "title": "Handle Supabase Login Responses and Errors",
            "description": "Implement robust error handling and success response formatting for the user login endpoint. This includes parsing the `data` and `error` objects returned by `supabase.auth.signInWithPassword` and returning appropriate HTTP status codes (e.g., 200 OK, 400 Bad Request, 401 Unauthorized) and user-friendly messages.",
            "dependencies": [
              3
            ],
            "details": "For success, return 200 OK with the user's session token and user data. For errors, identify common Supabase errors (e.g., `Invalid login credentials`, `User not found`) and map them to specific HTTP status codes (e.g., 401 for unauthorized, 400 for bad input) and descriptive error messages. Implement a generic 500 for unexpected errors.",
            "status": "done",
            "testStrategy": "Write unit/integration tests for the login endpoint: Test with valid credentials (expect 200 OK and session data). Test with incorrect password for an existing user (expect 401 Unauthorized). Test with a non-existent email (expect 401 Unauthorized or 404 Not Found, depending on desired security level). Test with missing credentials (expect 400 Bad Request)."
          }
        ]
      },
      {
        "id": 62,
        "title": "JWT Generation & Response (Backend)",
        "description": "After successful authentication with Supabase, extract the JWT (access token) and return it to the frontend in the API response.",
        "details": "Upon successful `signInWithPassword` or `signUp`, Supabase returns a session object containing the `access_token`. Extract this token and include it in the Hono response body, e.g., `c.json({ accessToken: session.access_token })`.",
        "testStrategy": "Perform a successful login/signup via the API. Verify that the API response includes a valid JWT in the `accessToken` field.",
        "priority": "high",
        "dependencies": [
          61
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 63,
        "title": "Frontend Auth Forms (Login, Signup UI)",
        "description": "Develop the user interface for signup and login forms on the frontend, utilizing `shadcn/ui` components.",
        "details": "Create `src/pages/LoginPage.tsx` and `src/pages/SignupPage.tsx`. Use `shadcn/ui` components like `Input`, `Button`, `Label`, `Card` to build the forms. Include fields for email and password. Add basic client-side validation (e.g., required fields).",
        "testStrategy": "Navigate to `/login` and `/signup`. Verify that the forms render correctly, inputs are interactive, and basic UI validation works.",
        "priority": "medium",
        "dependencies": [
          54,
          56
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold Auth Pages and Verify Shadcn/ui Setup",
            "description": "Create the base files for the login and signup pages and ensure that `shadcn/ui` components are correctly configured and importable within the project.",
            "dependencies": [],
            "details": "Create `src/pages/LoginPage.tsx` and `src/pages/SignupPage.tsx`. Add a basic functional component structure to each. Verify `shadcn/ui` installation by attempting to import and render a simple component like `Button` or `Card` in one of the new pages to confirm no setup issues.",
            "status": "done",
            "testStrategy": "Verify `LoginPage.tsx` and `SignupPage.tsx` files exist and render a basic 'Hello World' or a placeholder `shadcn/ui` component without errors in the browser."
          },
          {
            "id": 2,
            "title": "Implement Login Form UI with Shadcn/ui",
            "description": "Develop the user interface for the login form in `LoginPage.tsx` using `shadcn/ui` components, including fields for email and password, and a submit button.",
            "dependencies": [
              1
            ],
            "details": "In `src/pages/LoginPage.tsx`, utilize `shadcn/ui` components such as `Card` for the form container, `Label` and `Input` for email and password fields, and `Button` for the submit action. Structure the form semantically within a `<form>` tag. Focus solely on the visual layout and component integration; no form state management or validation logic is needed at this stage.",
            "status": "done",
            "testStrategy": "Visually inspect `LoginPage.tsx` in the browser to ensure all specified `shadcn/ui` components (Card, Label, Input, Button) are rendered correctly and the form layout is as expected."
          },
          {
            "id": 3,
            "title": "Implement Signup Form UI with Shadcn/ui",
            "description": "Develop the user interface for the signup form in `SignupPage.tsx` using `shadcn/ui` components, including fields for email and password, and a submit button.",
            "dependencies": [
              1
            ],
            "details": "In `src/pages/SignupPage.tsx`, replicate the UI structure from the login form (Subtask 2). Use `shadcn/ui` `Card`, `Label`, `Input` for email and password fields, and `Button` for the submit action. Ensure consistency in design and component usage with the login form. No form state management or validation logic is needed yet.",
            "status": "done",
            "testStrategy": "Visually inspect `SignupPage.tsx` in the browser to confirm all `shadcn/ui` components are rendered correctly and the form layout mirrors the login form's structure."
          },
          {
            "id": 4,
            "title": "Add Client-Side Validation to Login Form",
            "description": "Implement basic client-side validation for the email and password fields in the login form, providing immediate user feedback.",
            "dependencies": [
              2
            ],
            "details": "Integrate a form library like `react-hook-form` with `zod` for schema validation into `LoginPage.tsx`. Define a schema that marks email and password as required fields. Add basic email format validation. Display validation error messages next to the respective input fields using `shadcn/ui`'s `FormMessage` or similar pattern. The form should prevent submission if validation fails.",
            "status": "done",
            "testStrategy": "Attempt to submit the login form with empty fields, invalid email format, and valid credentials. Verify that appropriate error messages appear for invalid inputs and disappear for valid ones. Ensure the form cannot be submitted when validation errors are present."
          },
          {
            "id": 5,
            "title": "Add Client-Side Validation to Signup Form",
            "description": "Implement basic client-side validation for the email and password fields in the signup form, consistent with the login form's validation.",
            "dependencies": [
              3,
              4
            ],
            "details": "Apply the same client-side validation approach (e.g., `react-hook-form` with `zod`) to `SignupPage.tsx`. Ensure email and password fields are marked as required and email has basic format validation. Display validation error messages using `shadcn/ui` components. Maintain consistency in validation rules and error display with the login form.",
            "status": "done",
            "testStrategy": "Attempt to submit the signup form with empty fields, invalid email format, and valid credentials. Verify that appropriate error messages appear for invalid inputs and disappear for valid ones. Ensure the form cannot be submitted when validation errors are present."
          }
        ]
      },
      {
        "id": 64,
        "title": "Frontend Auth API Integration & Token Storage",
        "description": "Implement the frontend logic to send authentication requests to the backend, store the received JWT securely, and update the global authentication state.",
        "details": "In `LoginPage.tsx` and `SignupPage.tsx`, add event handlers for form submission. Use `fetch` or `axios` to send POST requests to `/api/auth/login` or `/api/auth/signup`. On success, store the `accessToken` in `localStorage` and update the Zustand auth store. Redirect the user to a protected route (e.g., `/stories`).",
        "testStrategy": "Perform a full signup and login flow from the frontend. Verify that the JWT is stored in `localStorage`, the Zustand store reflects the authenticated state, and the user is redirected correctly. Test with invalid credentials to ensure error handling.",
        "priority": "high",
        "dependencies": [
          55,
          62,
          63
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Auth API Utility Functions",
            "description": "Develop reusable utility functions for making POST requests to the authentication endpoints (`/api/auth/login` and `/api/auth/signup`). These functions will encapsulate the API call logic.",
            "dependencies": [],
            "details": "Create a new file (e.g., `src/services/authService.ts`) that exports asynchronous functions like `loginUser(credentials: LoginCredentials)` and `signupUser(userData: SignupData)`. These functions should use `fetch` or `axios` to send POST requests, set `Content-Type: application/json` headers, and handle JSON serialization/deserialization. They should return the parsed response data or throw an error on failure.",
            "status": "done",
            "testStrategy": "Unit test the utility functions with mock API responses to ensure they correctly format requests and parse successful/error responses."
          },
          {
            "id": 2,
            "title": "Implement Login Form Submission and Token Storage",
            "description": "Integrate the `loginUser` API utility function into `LoginPage.tsx` to handle form submission. On successful login, securely store the received JWT in `localStorage` and update the global Zustand authentication store.",
            "dependencies": [
              1
            ],
            "details": "In `LoginPage.tsx`, add an `onSubmit` handler to the login form. Call the `loginUser` utility function with the form data (username/email and password). If the API call is successful, extract the `accessToken` from the response. Store this token using `localStorage.setItem('accessToken', token)`. Update the Zustand auth store (e.g., `useAuthStore.setState({ isAuthenticated: true, token: token })`). After successful login and state update, redirect the user to a protected route like `/stories` using `useNavigate`.",
            "status": "done",
            "testStrategy": "Manually test login with valid credentials. Verify the token is stored correctly in `localStorage` and the Zustand store. Confirm successful redirection to `/stories`."
          },
          {
            "id": 3,
            "title": "Implement Signup Form Submission and Redirection",
            "description": "Integrate the `signupUser` API utility function into `SignupPage.tsx` to handle form submission. On successful signup, redirect the user to the login page.",
            "dependencies": [
              1
            ],
            "details": "In `SignupPage.tsx`, add an `onSubmit` handler to the signup form. Call the `signupUser` utility function with the form data (username, email, password). If the API call is successful, use `useNavigate` to redirect the user to the `/login` page. No token storage is required here, as the user will log in separately after signing up.",
            "status": "done",
            "testStrategy": "Manually test signup with valid user data. Verify successful redirection to `/login` upon completion."
          },
          {
            "id": 4,
            "title": "Implement Auth State-Based Route Protection",
            "description": "Add logic to protect routes and redirect users based on their authentication status. This includes redirecting unauthenticated users from protected routes and authenticated users from authentication pages.",
            "dependencies": [
              2
            ],
            "details": "Create a higher-order component (HOC) or a custom hook (e.g., `useAuthRedirect` or `ProtectedRoute`) that checks the authentication status from the Zustand store and `localStorage`. For protected routes (e.g., `/stories`), if `isAuthenticated` is false, redirect to `/login`. For authentication routes (`/login`, `/signup`), if `isAuthenticated` is true, redirect to `/stories`. Apply this logic to the relevant routes in your routing configuration (e.g., `App.tsx` or a dedicated `Routes.tsx` file).",
            "status": "done",
            "testStrategy": "Test navigating to `/stories` when logged out (should redirect to `/login`). Test navigating to `/login` or `/signup` when already logged in (should redirect to `/stories`)."
          },
          {
            "id": 5,
            "title": "Implement API Error Handling and User Feedback",
            "description": "Enhance the login and signup functionalities to gracefully handle API errors (e.g., invalid credentials, network issues) and display appropriate error messages to the user.",
            "dependencies": [
              2,
              3
            ],
            "details": "Modify the `onSubmit` handlers in `LoginPage.tsx` and `SignupPage.tsx` to include `try-catch` blocks around the API calls. If an error occurs (e.g., `response.ok` is false, or a network error), extract the error message from the API response (if available) or provide a generic error message. Use a state variable (e.g., `errorMessage`) to store the error and display it prominently on the respective page (e.g., below the form or as a toast notification). Clear the error message on subsequent successful attempts or form resets.",
            "status": "done",
            "testStrategy": "Test login with invalid credentials (expect error message). Test signup with existing user data (expect error message). Simulate network errors (e.g., by turning off the backend server) to ensure a generic error message is displayed."
          }
        ]
      },
      {
        "id": 65,
        "title": "Backend Auth Middleware (JWT validation)",
        "description": "Implement a Hono middleware on the backend to validate JWTs from the `Authorization` header for protected API endpoints.",
        "details": "Create a middleware function (e.g., `src/middleware/auth.ts`) that extracts the `Bearer` token from the `Authorization` header. Use Supabase's `auth.getUser()` or a JWT library to verify the token's validity. If valid, attach user info to the context; otherwise, return a 401 Unauthorized response. Apply this middleware to protected routes using `app.use('/api/protected/*', authMiddleware)`.",
        "testStrategy": "Create a dummy protected endpoint (e.g., `/api/protected/test`). Attempt to access it without a token, with an invalid token, and with a valid token. Verify 401 Unauthorized for invalid/missing tokens and success for valid tokens.",
        "priority": "high",
        "dependencies": [
          62
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Hono Auth Middleware File",
            "description": "Create the `src/middleware/auth.ts` file and define the basic Hono middleware function structure, including importing necessary Hono types and the `Context` object.",
            "dependencies": [],
            "details": "This subtask sets up the foundational file and boilerplate for the authentication middleware. The function should accept `c` (Context) and `next` (Next function) parameters.",
            "status": "done",
            "testStrategy": "Verify the creation of `src/middleware/auth.ts` and that it contains a valid Hono middleware function signature."
          },
          {
            "id": 2,
            "title": "Extract and Validate Authorization Header",
            "description": "Within the `auth.ts` middleware, implement logic to extract the `Bearer` token from the `Authorization` header. If the header is missing or not in 'Bearer <token>' format, immediately return a `401 Unauthorized` Hono response.",
            "dependencies": [
              1
            ],
            "details": "Access `c.req.header('Authorization')`. Check for existence and the 'Bearer ' prefix. If invalid, use `c.json({ message: 'Unauthorized' }, 401)`.",
            "status": "done",
            "testStrategy": "Unit test the middleware with requests having no Authorization header, malformed headers, and correctly formatted 'Bearer' headers to ensure proper token extraction or 401 response."
          },
          {
            "id": 3,
            "title": "Implement JWT Verification Logic",
            "description": "Integrate a JWT verification mechanism (e.g., Supabase `auth.getUser()` or a dedicated JWT library like `jose` or `jsonwebtoken`) to validate the extracted token's signature, expiration, and other claims. Handle any errors during verification.",
            "dependencies": [
              2
            ],
            "details": "This is the core security logic. If using Supabase, call `supabase.auth.getUser(token)`. If using a library, use its `verify` function with your JWT secret/public key. Wrap this in a `try-catch` block to handle verification failures.",
            "status": "done",
            "testStrategy": "Unit test the verification logic with valid, expired, tampered, and malformed JWTs to ensure correct validation outcomes and error handling."
          },
          {
            "id": 4,
            "title": "Attach User Info to Context or Return Unauthorized",
            "description": "Based on the JWT verification result from the previous step, if the token is valid, attach the decoded user information (e.g., `userId`, `email`, `role`) to the Hono context using `c.set('user', userData)`. If the token is invalid or verification fails, return a `401 Unauthorized` Hono response.",
            "dependencies": [
              3
            ],
            "details": "Ensure the `user` object attached to the context is accessible by subsequent route handlers. For invalid tokens, use `c.json({ message: 'Invalid or expired token' }, 401)`.",
            "status": "done",
            "testStrategy": "Integration test the middleware with valid and invalid tokens. For valid tokens, verify that user data is correctly attached to the context. For invalid tokens, confirm a 401 response is returned."
          },
          {
            "id": 5,
            "title": "Apply Middleware to Protected Routes and Test",
            "description": "Import the completed `authMiddleware` into the main Hono application file (e.g., `src/index.ts` or `src/app.ts`) and apply it to a specific path pattern using `app.use('/api/protected/*', authMiddleware)`. Create a simple protected endpoint to verify its functionality.",
            "dependencies": [
              4
            ],
            "details": "Add a dummy route like `/api/protected/data` that attempts to access `c.get('user')`. Test access with and without a valid JWT.",
            "status": "done",
            "testStrategy": "End-to-end test by making HTTP requests to the protected endpoint: 1) without any token (expect 401), 2) with an invalid token (expect 401), and 3) with a valid token (expect 200 and access to user data)."
          }
        ]
      },
      {
        "id": 66,
        "title": "Supabase Schema for Stories & Illustrations",
        "description": "Define and implement the necessary database schemas in Supabase for storing generated stories and illustrations.",
        "details": "In Supabase SQL Editor, create tables: `stories` (columns: `id` (PK), `user_id` (FK to auth.users), `title`, `content`, `created_at`), and `illustrations` (columns: `id` (PK), `story_id` (FK to stories), `image_url`, `description`, `created_at`). Set up Row Level Security (RLS) policies to ensure users can only access their own stories.",
        "testStrategy": "Verify that the tables are created correctly in Supabase. Attempt to insert and retrieve data using the Supabase dashboard to confirm schema integrity and RLS (if implemented at this stage).",
        "priority": "high",
        "dependencies": [
          49
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 67,
        "title": "Frontend Story Submission Form",
        "description": "Develop the frontend form for authenticated users to submit text prompts for story generation.",
        "details": "Create `src/pages/StoryGenerationPage.tsx`. Use `shadcn/ui` components like `Textarea`, `Button`, `Label`. The form should allow users to input a text prompt. Ensure the form is only accessible to authenticated users (e.g., by checking the Zustand auth state and redirecting if not logged in).",
        "testStrategy": "Log in as a user and navigate to the story generation page. Verify the form renders correctly. Attempt to submit the form (it won't do anything yet, but ensure no immediate errors).",
        "priority": "medium",
        "dependencies": [
          54,
          56,
          64
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create StoryGenerationPage and Configure Routing",
            "description": "Create the `src/pages/StoryGenerationPage.tsx` file and set up the necessary routing configuration to make this page accessible within the application, for example, at `/generate-story`.",
            "dependencies": [],
            "details": "Ensure the page file is created and a route is defined in the main routing configuration (e.g., `react-router-dom`).",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Authentication Guard and Redirection",
            "description": "Add logic within `StoryGenerationPage.tsx` to check the user's authentication status using the Zustand auth state. If the user is not authenticated, redirect them to the login page or display an appropriate access denied message.",
            "dependencies": [
              1
            ],
            "details": "Utilize the existing Zustand store for authentication state. Implement a `useEffect` hook or similar mechanism to perform the check on component mount and redirect using `useNavigate` if needed.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Integrate Shadcn UI Form Components",
            "description": "Incorporate `shadcn/ui` components such as `Label`, `Textarea`, and `Button` into `StoryGenerationPage.tsx` to construct the basic layout for the story submission form.",
            "dependencies": [
              1
            ],
            "details": "Import and render the `Label` for the prompt, a `Textarea` for user input, and a `Button` for submission. Ensure basic structure is in place.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Develop Form State Management and Submission Logic",
            "description": "Implement state management for the text prompt input (e.g., using `useState` for the `Textarea` value). Add an event handler for the form submission button to capture the input value and prepare it for future API submission.",
            "dependencies": [
              3
            ],
            "details": "Connect the `Textarea` to a state variable. Create an `onSubmit` handler for the form or an `onClick` handler for the button that logs the current prompt value to the console for verification.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Apply Basic Styling and User Experience Enhancements",
            "description": "Apply basic styling to the form components to ensure readability and a clean layout. Add a placeholder to the `Textarea` and consider disabling the submit button if the input is empty.",
            "dependencies": [
              3,
              4
            ],
            "details": "Use Tailwind CSS classes (via `shadcn/ui` components) for spacing, padding, and alignment. Implement a simple conditional to disable the button based on the prompt's length.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 68,
        "title": "Backend Story Creation Endpoint (`POST /api/stories`)",
        "description": "Implement the backend API endpoint (`POST /api/stories`) that receives story generation requests from the frontend.",
        "details": "Create a Hono route `app.post('/api/stories', authMiddleware, async (c) => { /* ... */ })`. This endpoint will receive the text prompt from the frontend. Ensure it's protected by the authentication middleware.",
        "testStrategy": "Use Postman or `curl` with a valid JWT to send a POST request to `/api/stories` with a dummy text prompt. Verify that the endpoint is hit and the request body is correctly parsed.",
        "priority": "high",
        "dependencies": [
          57,
          65
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Hono Route and Apply Authentication Middleware",
            "description": "Set up the basic Hono `POST /api/stories` route and ensure the `authMiddleware` is correctly applied to protect the endpoint.",
            "dependencies": [],
            "details": "Create the `app.post('/api/stories', authMiddleware, async (c) => { /* ... */ })` structure within the Hono application. Verify that `authMiddleware` is properly imported and accessible in the scope.",
            "status": "done",
            "testStrategy": "Attempt to access the endpoint without authentication; it should return an unauthorized error. Access with valid authentication; it should reach the handler (even if it currently does nothing)."
          },
          {
            "id": 2,
            "title": "Parse and Validate Story Prompt from Request Body",
            "description": "Implement logic within the endpoint handler to parse the incoming JSON request body and validate that it contains a `prompt` field of type string.",
            "dependencies": [
              1
            ],
            "details": "Use `c.req.json()` to asynchronously parse the request body. Implement schema validation (e.g., using Zod) to ensure the `prompt` property is present, is a string, and meets any length constraints. Return an HTTP 400 Bad Request error if validation fails.",
            "status": "done",
            "testStrategy": "Send requests with missing `prompt`, `prompt` of an incorrect type (e.g., number), and a valid `prompt` string. Verify that appropriate 400 responses are returned for invalid inputs and that valid inputs are successfully parsed."
          },
          {
            "id": 3,
            "title": "Integrate with Story Generation Logic",
            "description": "Integrate the validated prompt with the actual story generation logic, which might involve calling an internal service function or an external AI model API.",
            "dependencies": [
              2
            ],
            "details": "Call the designated story generation function (e.g., `storyService.generateStory(prompt)`) with the extracted and validated prompt. Handle the asynchronous nature of this call, awaiting its completion.",
            "status": "done",
            "testStrategy": "Mock the `storyService.generateStory` function to return a predefined story. Send a valid request to the endpoint and verify that the mock function is called with the correct prompt."
          },
          {
            "id": 4,
            "title": "Implement Success Response",
            "description": "Construct and send a successful HTTP 200 OK response containing the newly generated story back to the frontend.",
            "dependencies": [
              3
            ],
            "details": "After the story generation logic successfully returns the generated story text, format the response body (e.g., `{ story: 'Generated story text' }`) and send it using `c.json()` with an HTTP 200 status code.",
            "status": "done",
            "testStrategy": "Send a valid request to the endpoint. Verify that the response body contains the expected generated story text and that the HTTP status code is 200 OK."
          },
          {
            "id": 5,
            "title": "Implement Robust Error Handling for Endpoint",
            "description": "Add comprehensive error handling to catch various potential issues, such as internal server errors during story generation or unexpected exceptions, returning appropriate HTTP status codes and informative messages.",
            "dependencies": [
              3,
              4
            ],
            "details": "Wrap the story generation and response logic in a `try-catch` block. Catch specific errors (e.g., `StoryGenerationFailedError`) and return appropriate HTTP 500 Internal Server Error responses with a user-friendly message. Implement a general catch-all for unexpected errors, returning a generic 500 error. Ensure consistent error response format (e.g., `{ error: 'message' }`).",
            "status": "done",
            "testStrategy": "Simulate failures in the `storyService.generateStory` function (e.g., by making it throw an error). Verify that the endpoint returns an HTTP 500 status code and an appropriate error message in the response body."
          }
        ]
      },
      {
        "id": 69,
        "title": "Zod Validation for Story Request (Backend)",
        "description": "Implement request body validation for the `/api/stories` endpoint using `zod` to ensure incoming data is well-formed.",
        "details": "Install `zod`. Define a Zod schema for the story request body (e.g., `z.object({ prompt: z.string().min(1) })`). Use `zod` to parse and validate the `c.req.json()` body. Return a 400 Bad Request if validation fails.",
        "testStrategy": "Send requests to `/api/stories` with valid and invalid (e.g., empty prompt, missing field) request bodies. Verify that valid requests proceed and invalid requests return a 400 status with appropriate error messages.",
        "priority": "high",
        "dependencies": [
          68
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Zod Schema for Story Request",
            "description": "Create a `zod` schema that accurately represents the expected structure and types of the `/api/stories` request body.",
            "dependencies": [],
            "details": "Install `zod` if not already installed (`npm install zod` or `yarn add zod`). Define the `storyRequestSchema` using `z.object({ prompt: z.string().min(1, 'Prompt cannot be empty.') })`. Consider placing this schema definition in a dedicated file (e.g., `src/schemas/storySchema.ts`) for better organization.",
            "status": "done",
            "testStrategy": "N/A (schema definition only)"
          },
          {
            "id": 2,
            "title": "Integrate Zod Schema into `/api/stories` Handler",
            "description": "Modify the `/api/stories` POST handler to use the defined Zod schema for parsing the incoming request body.",
            "dependencies": [
              1
            ],
            "details": "Locate the `POST` handler for `/api/stories`. Import the `storyRequestSchema` defined in Subtask 1. Inside the handler, before processing the request, attempt to parse the `c.req.json()` body using `storyRequestSchema.safeParse(await c.req.json())`. Store the result in a variable (e.g., `validationResult`).",
            "status": "done",
            "testStrategy": "Manually send a valid request to the `/api/stories` endpoint. Verify that the request is processed without immediate errors related to schema integration. No specific validation error handling is expected at this stage."
          },
          {
            "id": 3,
            "title": "Implement Successful Validation Logic",
            "description": "Extract the validated data when `zod` parsing is successful and proceed with the existing business logic for creating a story.",
            "dependencies": [
              2
            ],
            "details": "After calling `storyRequestSchema.safeParse()`, check `if (validationResult.success)`. If true, destructure `validationResult.data` to get the validated fields (e.g., `const { prompt } = validationResult.data;`). Replace any direct usage of `c.req.json().prompt` with `prompt` in the subsequent story creation logic.",
            "status": "done",
            "testStrategy": "Send a valid request (e.g., `{ \"prompt\": \"A cat flying a spaceship\" }`) to `/api/stories`. Verify that the story is created successfully and the response is as expected for a successful operation (e.g., 200 OK or 201 Created)."
          },
          {
            "id": 4,
            "title": "Implement Failed Validation Error Handling",
            "description": "Return a `400 Bad Request` response with detailed error messages if `zod` validation fails.",
            "dependencies": [
              3
            ],
            "details": "In the `else` block of the `if (validationResult.success)` check, access `validationResult.error.issues` to get the validation errors. Format these issues into a user-friendly array of strings (e.g., `['prompt: Prompt cannot be empty.']`). Return `c.json({ errors: formattedErrors }, 400)`.",
            "status": "done",
            "testStrategy": "Send various invalid requests to `/api/stories`: 1. Missing `prompt` field (e.g., `{}`). 2. Empty `prompt` string (e.g., `{ \"prompt\": \"\" }`). 3. `prompt` with incorrect type (e.g., `{ \"prompt\": 123 }`). For each, verify that a `400 Bad Request` status is returned and the response body contains appropriate error messages."
          },
          {
            "id": 5,
            "title": "Add Unit/Integration Tests for Validation",
            "description": "Write automated tests to cover both successful and failed validation scenarios for the `/api/stories` endpoint.",
            "dependencies": [
              4
            ],
            "details": "Create a new test file (e.g., `src/api/stories.test.ts`). Use a testing framework (e.g., Vitest, Jest, Supertest) to simulate requests to the `/api/stories` endpoint. Include test cases for: 1. Valid request (expect 200/201). 2. Missing `prompt` (expect 400 with specific error). 3. Empty `prompt` (expect 400 with specific error). 4. `prompt` of wrong type (expect 400 with specific error). Assert on both status codes and response body content.",
            "status": "done",
            "testStrategy": "Run the automated test suite. All validation-related tests should pass, confirming the robustness of the implemented validation logic."
          }
        ]
      },
      {
        "id": 70,
        "title": "Gemini API Call for Story Generation (Backend)",
        "description": "Integrate the Google Gemini API to generate story content based on the user's prompt within the backend.",
        "details": "Within the `/api/stories` endpoint, after validation, call the Gemini API client (from Task 59) to generate text. Use a prompt engineering strategy to guide Gemini to produce coherent story content. Example: `const model = genAI.getGenerativeModel({ model: 'gemini-pro' }); const result = await model.generateContent(prompt); const response = await result.response; const text = response.text();`.",
        "testStrategy": "Send a valid story prompt to `/api/stories`. Verify that the backend successfully calls the Gemini API and receives a generated story text. Log the generated text to confirm content generation.",
        "priority": "high",
        "dependencies": [
          59,
          69
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 71,
        "title": "Gemini API Call for Illustration Generation (Backend)",
        "description": "Integrate the Google Gemini API to generate an illustration based on the generated story content, focusing on character consistency.",
        "details": "After story generation, use the generated story text (or a summary/key elements from it) to make another call to the Gemini API (or a separate image generation model if Gemini supports it directly, or a different Google AI service for image generation). This is a key R&D item for character consistency. Example: `const imageModel = genAI.getGenerativeModel({ model: 'gemini-pro-vision' }); const imageResult = await imageModel.generateContent(storyText, 'Generate an illustration for this story...');` (Note: Gemini Pro Vision is for multimodal input, not direct image generation. A separate image generation API like Imagen or a different model might be needed. Research best approach for image generation and consistency).",
        "testStrategy": "After story generation, verify that the backend attempts to call the image generation API. Log the API response (e.g., image URL or base64 data) to confirm image generation. Manually inspect generated images for initial consistency.",
        "priority": "high",
        "dependencies": [
          59,
          70
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Research & Select Google AI Image Generation Service",
            "description": "Investigate available Google Cloud AI services (e.g., Vertex AI Image Generation, Imagen, or specific Gemini models) capable of text-to-image generation. Evaluate their features, pricing, and suitability for generating illustrations with a focus on character consistency. Select the most appropriate service and identify its specific API endpoints and authentication requirements.",
            "dependencies": [],
            "details": "Focus on official Google Cloud documentation. Consider `Imagen` or `Vertex AI Image Generation` as primary candidates. Document the chosen service, its capabilities, and any known limitations regarding character consistency. The output of this subtask is a clear decision on which Google AI service/API will be used for image generation.",
            "status": "done",
            "testStrategy": "N/A (Research phase, outcome is a documented decision)"
          },
          {
            "id": 2,
            "title": "Implement Backend API Client for Selected Image Service",
            "description": "Set up the backend environment to interact with the chosen Google AI image generation service. This involves installing necessary client libraries (e.g., Google Cloud SDK for Python/Node.js), configuring authentication (e.g., service account keys), and creating a dedicated module or service function to encapsulate API calls.",
            "dependencies": [
              1
            ],
            "details": "Create a wrapper function, e.g., `generateIllustration(prompt: string, options: object): Promise<Buffer>` that handles the API request and returns the raw image data. Ensure robust error handling for API calls. Use environment variables or secure configuration for API keys/service account paths.",
            "status": "done",
            "testStrategy": "Write a unit test for the API client function that sends a simple, hardcoded prompt and verifies a successful (non-error) response and that the response contains valid image data (e.g., checking buffer length or header)."
          },
          {
            "id": 3,
            "title": "Develop Prompt Engineering Strategy for Character Consistency",
            "description": "Design and implement the logic for constructing effective prompts for the image generation API. This subtask focuses on extracting key character descriptions, settings, and plot elements from the generated story content and formatting them into a prompt that guides the AI to maintain character consistency within a single complex illustration.",
            "dependencies": [
              1
            ],
            "details": "Explore techniques like using consistent character descriptors, specifying character traits, appearance, and actions clearly within the prompt. Implement a function `createIllustrationPrompt(storyContent: string): string` that takes the story text and returns an optimized prompt string for the chosen image generation service. Initial focus on generating a single, comprehensive illustration.",
            "status": "done",
            "testStrategy": "Write unit tests for the `createIllustrationPrompt` function with various story inputs to ensure it generates well-formed and descriptive prompts. Manually review generated prompts for clarity and inclusion of key story elements."
          },
          {
            "id": 4,
            "title": "Integrate Image Generation into Story Workflow",
            "description": "Modify the existing backend story generation service to incorporate the image generation step. After a story is successfully generated, use the story content to call the `createIllustrationPrompt` function (from Subtask 3) and then pass the resulting prompt to the image generation API client (from Subtask 2). This subtask connects the entire flow.",
            "dependencies": [
              2,
              3
            ],
            "details": "Ensure the story generation service passes the full story text or relevant summary to the image generation module. Handle the asynchronous nature of the API call. Log the prompt sent and the API response (or errors) for debugging purposes. The output of this step is the raw image data from the API call.",
            "status": "done",
            "testStrategy": "Perform an integration test where a full story generation request is made, and verify that the image generation API is called with a valid prompt and returns image data. Check backend logs for successful API calls and any errors."
          },
          {
            "id": 5,
            "title": "Implement Image Storage and Retrieval Mechanism",
            "description": "Develop the functionality to store the generated illustration securely and efficiently, and to make it retrievable by the frontend. This typically involves uploading the image data (received from Subtask 4) to a cloud storage solution (e.g., Google Cloud Storage) and storing its public URL or identifier in the database associated with the generated story.",
            "dependencies": [
              4
            ],
            "details": "Use Google Cloud Storage for image persistence. Implement a function `saveIllustration(imageData: Buffer, storyId: string): Promise<string>` that uploads the image and returns its public URL. Update the story's database entry with this URL. Consider appropriate image format (e.g., PNG, JPEG) and potential resizing if needed for performance.",
            "status": "done",
            "testStrategy": "Perform an end-to-end integration test: generate a story, confirm an image is generated, uploaded to GCS, and its URL is saved in the database. Verify that the image can be accessed via the stored URL."
          }
        ]
      },
      {
        "id": 72,
        "title": "Save Generated Content to Supabase (Backend)",
        "description": "Persist the generated story text and illustration details (e.g., image URL) into the Supabase database.",
        "details": "Within the `/api/stories` endpoint, after both story and illustration generation, use `supabase.from('stories').insert(...)` and `supabase.from('illustrations').insert(...)` to save the data. Ensure the `user_id` is correctly associated with the story (obtained from the JWT in the auth middleware).",
        "testStrategy": "Submit a story generation request. After successful API calls, check the Supabase `stories` and `illustrations` tables. Verify that new entries are created with the correct content, user ID, and story-illustration linkage.",
        "priority": "high",
        "dependencies": [
          58,
          66,
          70,
          71
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 73,
        "title": "Return Generated Content to Frontend (Backend)",
        "description": "Return the generated story content and illustration URL (or data) from the backend to the frontend.",
        "details": "After saving to Supabase, construct a JSON response containing the generated story text, illustration URL, and any other relevant metadata (e.g., story ID). Send this response back to the frontend using `c.json(...)`.",
        "testStrategy": "Submit a story generation request from the frontend. Verify that the frontend receives a JSON response containing the generated story text and illustration URL.",
        "priority": "high",
        "dependencies": [
          72
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 74,
        "title": "Display Generated Content (Frontend)",
        "description": "Implement the frontend logic to display the generated story text and illustration received from the backend.",
        "details": "On the `StoryGenerationPage.tsx` or a new `StoryDisplayPage.tsx`, update the UI to render the story text and display the image using an `<img>` tag. Handle loading states and potential errors during the API call.",
        "testStrategy": "Submit a story generation request from the frontend. Verify that the generated story text and illustration image are correctly displayed on the UI after the backend response is received.",
        "priority": "medium",
        "dependencies": [
          67,
          73
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize UI Components and State for Content Display",
            "description": "Create or identify the necessary React components (e.g., `StoryDisplayPage.tsx` or within `StoryGenerationPage.tsx`) and define the component's local state to manage `storyText` (string), `illustrationUrl` (string), `isLoading` (boolean), and `error` (string | null).",
            "dependencies": [],
            "details": "Use React's `useState` hook to define the state variables. Create a basic layout with placeholders for the story text and image. This subtask focuses purely on setting up the state and the initial empty UI structure.",
            "status": "done",
            "testStrategy": "Verify that the component renders without errors and the initial state variables are correctly initialized (e.g., `isLoading` is true, `storyText` and `illustrationUrl` are empty)."
          },
          {
            "id": 2,
            "title": "Integrate Content Fetching API Call and Loading Indicator",
            "description": "Implement the asynchronous function to call the backend API endpoint responsible for providing the generated story content (text and image URL). Manage the `isLoading` state to show a loading indicator while the fetch is in progress.",
            "dependencies": [
              1
            ],
            "details": "Use React's `useEffect` hook to trigger the API call when the component mounts or when a relevant dependency (e.g., a story ID) changes. Use `axios` or the native `fetch` API. Set `isLoading` to `true` before the call and `false` after it completes (success or failure). Display a simple loading spinner or 'Generating...' text when `isLoading` is true.",
            "status": "done",
            "testStrategy": "Simulate an API call (e.g., using a mock service worker or a test double). Verify that the loading indicator appears when the call starts and disappears when it completes. Check console logs for successful API calls."
          },
          {
            "id": 3,
            "title": "Render Generated Story Text",
            "description": "Update the UI to conditionally display the `storyText` received from the API call. Ensure proper formatting (e.g., paragraphs, line breaks) if applicable.",
            "dependencies": [
              2
            ],
            "details": "Once the API call in Subtask 2 successfully populates the `storyText` state, render this text within a designated area of the UI. Use appropriate HTML tags (e.g., `<p>` for paragraphs, `<div>` with `white-space: pre-wrap` for preserving line breaks if the text comes as a single string). Ensure the text is only displayed when `isLoading` is false and `storyText` is not empty.",
            "status": "done",
            "testStrategy": "After a successful API call, verify that the received story text is correctly rendered on the page. Test with multi-paragraph text to ensure formatting is preserved."
          },
          {
            "id": 4,
            "title": "Display Generated Illustration Image",
            "description": "Update the UI to conditionally display the `illustrationUrl` received from the API call using an `<img>` tag. Include appropriate alt text for accessibility.",
            "dependencies": [
              2
            ],
            "details": "After the API call in Subtask 2 successfully populates the `illustrationUrl` state, render an `<img>` tag with its `src` attribute set to `illustrationUrl`. Add a descriptive `alt` attribute (e.g., 'Illustration for the story'). Ensure the image is only displayed when `isLoading` is false and `illustrationUrl` is not empty.",
            "status": "done",
            "testStrategy": "After a successful API call, verify that the image is displayed correctly. Inspect the `<img>` tag to ensure the `src` and `alt` attributes are set as expected. Test with a broken image URL to ensure it handles gracefully (e.g., shows alt text)."
          },
          {
            "id": 5,
            "title": "Implement Comprehensive Error and Empty State Handling",
            "description": "Enhance the UI to display user-friendly error messages if the API call fails (e.g., network error, server error). Also, handle cases where no content is available or the generation process is still ongoing/failed to produce content.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Modify the API call logic in Subtask 2 to catch errors and update the `error` state. Conditionally render an error message component or text when the `error` state is populated. Additionally, if `isLoading` is false and both `storyText` and `illustrationUrl` are empty, display a 'No content available' or 'Story generation failed' message, providing clear feedback to the user.",
            "status": "done",
            "testStrategy": "Simulate API failures (e.g., network error, 500 status code) and verify that the correct error message is displayed. Test scenarios where the API returns empty text/URL to ensure the 'No content available' message appears. Verify that error messages clear when a new successful generation occurs."
          }
        ]
      },
      {
        "id": 75,
        "title": "Implement Robust Error Handling & Logging",
        "description": "Implement comprehensive error handling and logging mechanisms for both frontend and backend components to improve debugging and user experience.",
        "details": "Frontend: Use `try-catch` blocks for API calls, display user-friendly error messages using `shadcn/ui` `Toast` components. Backend: Implement centralized error handling middleware in Hono. Log errors to the console or a logging service (e.g., Cloudflare Logpush) with relevant context (request details, stack traces).",
        "testStrategy": "Trigger various error scenarios (e.g., invalid login, missing prompt, API key issues, database errors). Verify that appropriate error messages are displayed on the frontend and detailed errors are logged on the backend.",
        "priority": "medium",
        "dependencies": [
          64,
          65,
          69,
          70,
          71,
          72
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Backend: Implement Centralized Error Handling Middleware (Hono)",
            "description": "Create and integrate a Hono middleware to catch unhandled errors globally, ensuring all backend errors are intercepted before sending a response. This will standardize error responses.",
            "dependencies": [],
            "details": "Implement an `app.onError` handler or a custom middleware function in Hono. This handler should capture `Error` objects, extract relevant details (e.g., `error.message`, `error.stack`), and construct a standardized JSON error response (e.g., `{ status: 500, message: 'Internal Server Error', code: 'SERVER_ERROR' }`). Ensure it handles different types of errors gracefully.",
            "status": "done",
            "testStrategy": "Introduce intentional errors (e.g., `throw new Error('Test error')` in a route handler, access a non-existent variable) and verify that the standardized error response is returned by the API."
          },
          {
            "id": 2,
            "title": "Backend: Integrate Logging Service for Errors",
            "description": "Enhance the centralized error handler to log caught errors to a designated logging service (e.g., console for development, Cloudflare Logpush for production) with relevant context.",
            "dependencies": [
              1
            ],
            "details": "Within the Hono error middleware implemented in Subtask 1, add logic to send detailed error information to `console.error` or a dedicated logging utility. Include context such as request details (method, path, headers), timestamp, stack trace, and any available user information. For production, consider integrating with Cloudflare Logpush or a similar service.",
            "status": "done",
            "testStrategy": "Trigger various backend errors (e.g., invalid input, database connection issues, unhandled exceptions) and verify that detailed error logs appear in the console or the configured logging service, including stack traces and request context."
          },
          {
            "id": 3,
            "title": "Frontend: Implement `try-catch` for API Calls",
            "description": "Modify existing or future API call functions/wrappers to include `try-catch` blocks, ensuring that network and application-level errors from the backend are caught gracefully.",
            "dependencies": [],
            "details": "Identify common patterns for making API calls (e.g., using `fetch` directly or a custom wrapper). Wrap these calls in `try-catch` blocks. In the `catch` block, extract error information (e.g., `error.message`, `error.response.status`, or parsed JSON error body from backend). Centralize this error handling logic if possible (e.g., in a custom `fetch` wrapper).",
            "status": "done",
            "testStrategy": "Simulate API failures (e.g., by temporarily making a backend endpoint return a 500 error or by blocking network requests in browser dev tools) and verify that the `catch` block is executed and the error object contains relevant information."
          },
          {
            "id": 4,
            "title": "Frontend: Display User-Friendly Error Toasts (shadcn/ui)",
            "description": "Integrate `shadcn/ui` `Toast` components to display user-friendly error messages to the user when API calls or other frontend operations fail.",
            "dependencies": [
              3
            ],
            "details": "Utilize the `useToast` hook from `shadcn/ui`. In the `catch` blocks implemented in Subtask 3, call `toast({ variant: 'destructive', title: 'Error', description: 'A user-friendly message explaining the issue' })`. Map specific backend error codes or messages to more generic, user-facing descriptions to avoid exposing technical details. Ensure toasts are dismissible and provide clear feedback.",
            "status": "done",
            "testStrategy": "Trigger frontend API call failures (e.g., by making a backend endpoint return a 400 or 500 error). Verify that a `shadcn/ui` Toast component appears on the screen with an appropriate, user-friendly error message."
          },
          {
            "id": 5,
            "title": "Comprehensive Error Handling Testing & Documentation",
            "description": "Conduct end-to-end testing of the implemented error handling and logging mechanisms across various scenarios and document the setup for future maintenance and debugging.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Perform a thorough testing phase covering: 1. Backend: Verify logs for different error types (validation, runtime, network) and standardized responses. 2. Frontend: Test various API failure scenarios (4xx, 5xx, network offline) and confirm correct toast display. 3. End-to-end: Ensure frontend errors are logged on the backend if applicable. Document the error handling strategy, common error codes, how to interpret logs, and guidelines for adding new error types in the project's README or a dedicated `CONTRIBUTING.md`.",
            "status": "done",
            "testStrategy": "Create a test plan covering specific error scenarios for both frontend and backend. For each scenario, verify the expected user experience (toast message) and the backend logging output. Document the observed behavior and confirm it matches the desired robust error handling."
          }
        ]
      },
      {
        "id": 76,
        "title": "End-to-End Testing & Deployment Verification",
        "description": "Perform comprehensive end-to-end testing of all major features (authentication, story/illustration generation) and verify successful deployment to Cloudflare Pages.",
        "details": "Conduct manual and/or automated tests covering: user signup, login, logout; submitting a story prompt; verifying story and illustration generation and display; checking Supabase data integrity. Deploy the latest code to Cloudflare Pages and verify all functionalities work correctly in the production environment.",
        "testStrategy": "Execute a full user journey: signup, login, generate story/illustration, view generated content, logout. Verify all steps complete successfully. Confirm that the deployed application on Cloudflare Pages functions identically to the local development environment.",
        "priority": "high",
        "dependencies": [
          45,
          48,
          64,
          74,
          75
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "End-to-End Authentication Flow Testing",
            "description": "Conduct comprehensive end-to-end testing of user authentication features including signup, login, and logout processes.",
            "dependencies": [],
            "details": "Manually and/or automatically test user registration, successful login with valid credentials, failed login with invalid credentials, and proper logout functionality. Verify session management and error handling for authentication flows.",
            "status": "done",
            "testStrategy": "Manual testing with various user scenarios (new user, existing user, invalid credentials). Consider automated E2E tests if framework is in place."
          },
          {
            "id": 2,
            "title": "Story & Illustration Generation E2E Testing",
            "description": "Perform end-to-end testing of the core story and illustration generation features, from prompt submission to display.",
            "dependencies": [
              1
            ],
            "details": "Test submitting diverse story prompts, verifying the generation process, and ensuring the generated story text and illustration images are correctly displayed on the UI. Check for edge cases, prompt length variations, and error handling during generation.",
            "status": "done",
            "testStrategy": "Manual testing with varied prompt inputs (short, long, specific themes, unusual requests). Verify output against expectations and UI rendering."
          },
          {
            "id": 3,
            "title": "Supabase Data Integrity Verification",
            "description": "Verify the integrity and correctness of data stored in Supabase following story and illustration generation.",
            "dependencies": [
              2
            ],
            "details": "After generating stories and illustrations, inspect the Supabase database to ensure that all relevant data (story text, image URLs, user IDs, timestamps, prompt details) is correctly stored, linked, and consistent. Check for data corruption or missing entries.",
            "status": "done",
            "testStrategy": "Manual inspection of Supabase tables via its dashboard or programmatic queries. Cross-reference displayed data with database entries for accuracy and completeness."
          },
          {
            "id": 4,
            "title": "Deploy Latest Code to Cloudflare Pages",
            "description": "Deploy the latest stable version of the application code to the Cloudflare Pages production environment.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Trigger the CI/CD pipeline or manually deploy the current main/production branch to Cloudflare Pages. Monitor the deployment process for any errors or warnings, ensuring a successful build and publish.",
            "status": "done",
            "testStrategy": "Verify deployment status in Cloudflare Pages dashboard. Check build logs for success and absence of critical errors. Confirm the new version is live."
          },
          {
            "id": 5,
            "title": "Production Environment Functionality Verification",
            "description": "Conduct a final round of end-to-end testing on the live application deployed to Cloudflare Pages to confirm all features work correctly in production.",
            "dependencies": [
              4
            ],
            "details": "Repeat critical end-to-end tests for authentication (signup, login, logout), story/illustration generation, and display on the Cloudflare Pages URL. Verify responsiveness, performance, and any environment-specific configurations in the live setting.",
            "status": "done",
            "testStrategy": "Manual smoke testing of key features (login, generate story, view story) on the deployed URL. Compare behavior to local environment and ensure no regressions or production-specific issues."
          }
        ]
      },
      {
        "id": 77,
        "title": "Implement Story List Feature",
        "description": "Implement a backend API endpoint to retrieve a list of user-generated stories and create a new frontend page to display these stories, including a navigation link.",
        "details": "Backend (Hono): Create a new GET endpoint (e.g., /api/stories) to fetch stories. Implement logic to query Supabase for stories, ensuring proper authentication to filter by user_id. Consider adding pagination parameters for future scalability. Return a JSON array of story objects, including relevant metadata like id, title, creation date, and a snippet or illustration URL. Integrate robust error handling and logging as per Task 75. Frontend (Next.js/React): Create a new page component (e.g., /app/stories/page.tsx) responsible for fetching and displaying the list of stories. Utilize UI components (e.g., shadcn/ui Card or Table) to present the stories in an organized manner. Implement loading states and display user-friendly error messages using the Toast component from Task 75. Add a prominent link to this new 'My Stories' or 'Story List' page in the main application navigation.",
        "testStrategy": "Backend: Use a tool like Postman or curl to directly call the new API endpoint. Verify that it returns a list of stories for an authenticated user and an empty array for a user with no stories. Test with an unauthenticated request to ensure proper authorization handling (e.g., 401 Unauthorized). Frontend: Navigate to the new 'My Stories' page via the navigation link. Verify that the page loads correctly and displays the list of stories with accurate titles and details. Confirm that loading indicators are shown during data fetching. Simulate API errors (e.g., by temporarily modifying the backend response) to ensure appropriate error messages are displayed on the frontend. Verify the navigation link is correctly integrated and functional.",
        "status": "done",
        "dependencies": [
          72,
          75
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Core Backend API for Story Retrieval",
            "description": "Create the initial Hono GET endpoint `/api/stories` to fetch user-generated stories from Supabase. This subtask focuses on the core data retrieval and user authentication.",
            "dependencies": [],
            "details": "Create a new route in Hono (e.g., `src/api/stories.ts` or similar). Implement logic to query the `stories` table in Supabase. Ensure the query filters stories by `user_id` based on the authenticated user's ID. Return a JSON array of story objects including `id`, `title`, `created_at`, and a `snippet` or `illustration_url`. For now, do not implement pagination or advanced error handling beyond basic success/failure.",
            "status": "done",
            "testStrategy": "Use a tool like Postman or Insomnia, or write a simple `curl` command, to test the `/api/stories` endpoint. Verify that it returns stories for an authenticated user and no stories for an unauthenticated user or a user with no stories. Check the structure of the returned JSON."
          },
          {
            "id": 2,
            "title": "Enhance Backend API with Pagination and Robust Error Handling",
            "description": "Extend the `/api/stories` endpoint to support pagination parameters and integrate robust error handling and logging as per Task 75.",
            "dependencies": [
              1
            ],
            "details": "Modify the `/api/stories` endpoint to accept optional query parameters like `offset` and `limit` (e.g., `?offset=0&limit=10`). Implement the Supabase query to apply these pagination parameters. Integrate error handling for database query failures, authentication issues, or invalid parameters, returning appropriate HTTP status codes and error messages. Ensure logging is implemented for critical errors as per Task 75 guidelines.",
            "status": "done",
            "testStrategy": "Test the `/api/stories` endpoint with various `offset` and `limit` values to ensure correct pagination. Simulate errors (e.g., invalid authentication token, database connection issues if possible) to verify robust error responses and logging. Check logs for error entries."
          },
          {
            "id": 3,
            "title": "Create Frontend Story List Page and Data Fetching Logic",
            "description": "Develop the new Next.js page component (`/app/stories/page.tsx`) responsible for fetching the list of stories from the backend API, including handling loading and initial error states.",
            "dependencies": [
              2
            ],
            "details": "Create the file `app/stories/page.tsx`. Implement data fetching logic within this component (e.g., using `useEffect` with `fetch` or a data fetching library). Call the `/api/stories` endpoint. Implement a loading state (e.g., displaying a spinner or skeleton UI) while data is being fetched. Implement basic error handling to display user-friendly error messages using the Toast component from Task 75 if the API call fails.",
            "status": "done",
            "testStrategy": "Navigate directly to `/app/stories` in the browser. Verify that a loading state is displayed initially. Ensure that stories are fetched and available in the component's state. Simulate an API error (e.g., by temporarily disabling the backend or modifying the endpoint URL) to confirm that the error Toast message appears correctly."
          },
          {
            "id": 4,
            "title": "Implement Frontend Story List UI Display",
            "description": "Utilize UI components (e.g., shadcn/ui Card or Table) to present the fetched stories in an organized and user-friendly manner on the `/app/stories` page.",
            "dependencies": [
              3
            ],
            "details": "Using the data fetched in the previous subtask, render the list of stories. Choose appropriate shadcn/ui components like `Card` for individual stories or `Table` for a tabular display. Each story should display its `title`, `created_at`, and a `snippet` or `illustration_url` if available. Ensure the layout is responsive and visually appealing.",
            "status": "done",
            "testStrategy": "Verify that the fetched stories are correctly rendered on the page using the chosen UI components. Check that all relevant story metadata (title, date, snippet/image) is displayed. Test responsiveness on different screen sizes. Ensure the UI handles cases with no stories gracefully (e.g., displaying a 'No stories yet' message)."
          },
          {
            "id": 5,
            "title": "Integrate Story List Page into Application Navigation",
            "description": "Add a prominent navigation link to the new 'My Stories' or 'Story List' page in the main application navigation.",
            "dependencies": [
              4
            ],
            "details": "Locate the main application navigation component (e.g., `layout.tsx` or a dedicated `Navbar` component). Add a new navigation item with a clear label like 'My Stories' or 'Story List'. Ensure the link correctly points to `/app/stories`. Verify that the navigation item is visible and accessible.",
            "status": "done",
            "testStrategy": "Navigate through the application. Verify that the 'My Stories' link is present in the main navigation. Click the link and confirm that it correctly navigates to the `/app/stories` page and displays the story list. Check that the active state of the navigation link is correctly highlighted when on the stories page."
          },
          {
            "id": 6,
            "title": "バックエンドAPIの作成（詳細取得）",
            "description": "特定のIDの物語を取得するAPIエンドポイント（例: GET /api/v1/posts/:id）を作成します。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 77
          },
          {
            "id": 7,
            "title": "フロントエンド詳細ページの実装",
            "description": "詳細ページコンポーネントを作成し、APIから取得した物語の全文と大きなイラストを表示します。",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 77
          }
        ]
      },
      {
        "id": 78,
        "title": "Display Latest Stories on Homepage",
        "description": "Implement a backend API to retrieve the 3 most recent stories and integrate this API into the frontend homepage to display them.",
        "details": "Backend (Hono): Create a new GET endpoint (e.g., /api/stories/latest) that queries the 'stories' table in Supabase. Order the results by 'created_at' in descending order and limit the results to 3. Ensure the API returns necessary fields for display such as 'id', 'title', 'illustration_url', and 'created_at'. Implement robust error handling and logging as per Task 75. Consider if these stories should be publicly accessible or only for logged-in users; for a homepage, public access is generally preferred. Frontend (Next.js/React): On the main homepage component (e.g., app/page.tsx), fetch data from the new /api/stories/latest endpoint. Display the retrieved stories in a dedicated section using appropriate UI components (e.g., shadcn/ui Card components) to present each story with its title and illustration. Implement loading states and error display using Toast components as per Task 75. Ensure responsive design for various screen sizes.",
        "testStrategy": "Backend: Use a tool like Postman or curl to call the /api/stories/latest endpoint. Verify that it returns exactly 3 stories, ordered by creation date (newest first). Test with an empty database or fewer than 3 stories to ensure correct behavior (e.g., returns 0, 1, or 2 stories). Verify error handling by simulating database errors or invalid requests. Frontend: Navigate to the homepage in a browser. Verify that the 'Latest Stories' section appears and displays 3 story cards/previews with correct titles and illustrations. Check responsiveness across different screen sizes. Simulate API failure (e.g., by temporarily disabling the backend endpoint) and verify that an appropriate error message is displayed on the UI.",
        "status": "done",
        "dependencies": [
          75,
          77
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Hono API to Fetch Latest 3 Stories",
            "description": "Create a new GET endpoint `/api/stories/latest` in the Hono backend. This endpoint should query the `stories` table in Supabase, order results by `created_at` in descending order, and limit the results to 3. The API must return `id`, `title`, `illustration_url`, and `created_at` for each story.",
            "dependencies": [],
            "details": "Use the Supabase client to perform the database query. Ensure the response format is a JSON array of story objects. This endpoint should be publicly accessible for the homepage display.",
            "status": "done",
            "testStrategy": "Use Postman, Insomnia, or `curl` to hit the `/api/stories/latest` endpoint. Verify that exactly 3 stories are returned, ordered by `created_at` descending, and contain the required fields (`id`, `title`, `illustration_url`, `created_at`)."
          },
          {
            "id": 2,
            "title": "Add Robust Error Handling and Logging to Latest Stories API",
            "description": "Enhance the `/api/stories/latest` endpoint with comprehensive error handling for database query failures, network issues, or unexpected data formats from Supabase. Implement logging for successful requests and errors as per Task 75 guidelines.",
            "dependencies": [
              1
            ],
            "details": "Wrap the Supabase query logic in a `try-catch` block. Return appropriate HTTP status codes (e.g., 500 for server errors, 200 with an empty array if no stories are found). Log errors with relevant context (e.g., error message, stack trace) and successful requests.",
            "status": "done",
            "testStrategy": "Simulate database errors (e.g., by temporarily invalidating Supabase credentials or querying a non-existent column) to verify that the API returns an appropriate error response (e.g., 500 status code) and logs the error correctly. Verify successful requests are logged."
          },
          {
            "id": 3,
            "title": "Implement Frontend Data Fetching and Loading/Error States",
            "description": "In the `app/page.tsx` component (or equivalent homepage component), implement logic to fetch data from the new `/api/stories/latest` endpoint. Manage loading states (e.g., `isLoading` boolean) and error states (e.g., `isError`, `errorMessage`).",
            "dependencies": [
              2
            ],
            "details": "Use React's `useEffect` and `useState` hooks for data fetching and state management. Implement a loading indicator (e.g., a skeleton loader or spinner) that displays while data is being fetched. If an error occurs during fetching, display an error message using a shadcn/ui Toast component as per Task 75.",
            "status": "done",
            "testStrategy": "Manually test by refreshing the homepage to observe the loading state. Temporarily modify the backend API to return an error to verify the error message and Toast component are displayed correctly. Verify that no error is shown on successful fetch."
          },
          {
            "id": 4,
            "title": "Integrate Fetched Stories into Homepage UI",
            "description": "Display the successfully fetched latest stories on the homepage. Use shadcn/ui Card components (or similar appropriate UI components) to present each story, showing its `title` and `illustration_url`. Ensure the layout is clean and visually appealing.",
            "dependencies": [
              3
            ],
            "details": "Map over the `stories` array received from the API. For each story, render a `Card` component. Use the `illustration_url` for an `img` tag within the card and the `title` for the card's header or title section. Ensure images have appropriate `alt` text.",
            "status": "done",
            "testStrategy": "Verify that 3 stories are displayed on the homepage. Check that each story card correctly shows its title and illustration. Ensure images load without errors and are appropriately sized within the cards."
          },
          {
            "id": 5,
            "title": "Ensure Responsive Design and Apply Final UI Polish",
            "description": "Optimize the display of the latest stories section for various screen sizes (mobile, tablet, desktop). Apply any necessary final styling adjustments to ensure a polished and consistent user experience across devices.",
            "dependencies": [
              4
            ],
            "details": "Use CSS media queries or Tailwind CSS utility classes (e.g., `grid-cols-1 sm:grid-cols-2 lg:grid-cols-3`) to adjust the layout of the story cards based on viewport width. Ensure images scale correctly, text remains readable, and there is appropriate spacing and alignment.",
            "status": "done",
            "testStrategy": "Test the homepage on different browser widths or using browser developer tools' responsive mode. Verify that the story cards adapt gracefully to smaller screens (e.g., stacking vertically) and larger screens (e.g., displaying in a grid). Check for any visual glitches or misalignments."
          }
        ]
      },
      {
        "id": 79,
        "title": "Project Initialization and Core Structure Setup",
        "description": "Initialize the project with Vite for the frontend and Hono for the backend, establishing the specified directory structure (`functions/`, `src/`, `public/`). Configure `package.json` for monorepo-like management.",
        "details": "Use `npm create vite@latest` for React/TypeScript frontend. Manually create `functions/api/[[path]].ts` for Hono. Ensure `index.html` is at the root. Set up `tsconfig.json` for both frontend and backend. Install core dependencies: `react`, `react-dom`, `hono`, `vite`, `typescript`.",
        "testStrategy": "Verify project structure matches PRD. Run `npm install` successfully. Confirm basic Vite and Hono setup by creating a minimal 'Hello World' endpoint in Hono and displaying it in React.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 80,
        "title": "Local Development Environment Configuration",
        "description": "Configure the local development environment to run Vite (frontend) and Hono (backend) concurrently using `wrangler` and `vite.config.ts` proxy settings.",
        "details": "Install `wrangler` and `concurrently`. Add scripts to `package.json` for `dev:frontend`, `dev:backend`, and `dev` (using `concurrently`). Configure `vite.config.ts` to proxy `/api/*` requests to the `wrangler` development server (e.g., `http://localhost:8787`). Example `vite.config.ts` proxy: `{ '/api': { target: 'http://localhost:8787', changeOrigin: true } }`.",
        "testStrategy": "Run `npm run dev`. Access the frontend in the browser. Make a test API call from the frontend (e.g., to `/api/health`) and verify it successfully reaches the Hono backend and returns a response.",
        "priority": "high",
        "dependencies": [
          79
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 81,
        "title": "Cloudflare Pages/Functions Deployment Pipeline Setup",
        "description": "Set up the Cloudflare Pages and Functions deployment pipeline, triggered by `git push`.",
        "details": "Connect the GitHub repository to Cloudflare Pages. Configure build settings: Build command `npm run build` (or similar), Build output directory `dist` (Vite default). For Functions, ensure Cloudflare Pages automatically detects the `functions` directory. Verify `wrangler.toml` is correctly configured if needed, though Pages Functions often work out-of-the-box with the `functions` directory.",
        "testStrategy": "Perform a `git push` to a test branch. Monitor Cloudflare Pages dashboard to ensure successful build and deployment of both the static SPA and the Pages Functions. Access the deployed URL and verify the application loads and a test API endpoint is reachable.",
        "priority": "high",
        "dependencies": [
          79,
          80
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 82,
        "title": "Environment Variable Management Setup",
        "description": "Establish a robust environment variable management system for both local development and production deployments.",
        "details": "For frontend, use `.env` with `VITE_` prefix (e.g., `VITE_SUPABASE_URL`). For backend, use `.dev.vars` for local development and Cloudflare Pages console for production. Document all required environment variables (e.g., Supabase keys, Gemini API key). Ensure `.env` and `.dev.vars` are in `.gitignore`.",
        "testStrategy": "Verify environment variables are correctly loaded in both frontend and backend during local development. Deploy a test change and confirm production environment variables are accessible within the Cloudflare Pages Functions and frontend build.",
        "priority": "high",
        "dependencies": [
          79
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 83,
        "title": "Supabase Project Setup and Initial Stories Schema",
        "description": "Set up the Supabase project, including initial database schema for `stories` and configuring the Supabase client in the backend.",
        "details": "Create a new Supabase project. Define the `stories` table with columns: `id` (PK, UUID), `user_id` (FK to `auth.users`), `title` (text), `story_text` (text), `illustration_url` (text), `created_at` (timestamp, default `now()`). Configure the Supabase client in the Hono backend using `createClient` from `@supabase/supabase-js`, utilizing environment variables for `SUPABASE_URL` and `SUPABASE_ANON_KEY`.",
        "testStrategy": "Verify the `stories` table is created in Supabase. Write a simple backend Hono endpoint to insert a dummy record into `stories` and confirm successful insertion via Supabase Studio.",
        "priority": "high",
        "dependencies": [
          82
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 84,
        "title": "Backend Authentication: Signup Endpoint",
        "description": "Implement the backend API endpoint for user signup (`/api/auth/signup`) using Hono and Supabase authentication.",
        "details": "Create a Hono route `POST /api/auth/signup`. Use `zod` for request body validation (email, password). Call `supabase.auth.signUp({ email, password })`. Handle success (return JWT) and error responses. Ensure secure password handling (Supabase handles hashing).",
        "testStrategy": "Use a tool like Postman or a simple `fetch` call to `POST /api/auth/signup` with valid and invalid credentials. Verify a new user is created in Supabase `auth.users` table and a JWT is returned on success. Test error cases (e.g., existing email, invalid format).",
        "priority": "high",
        "dependencies": [
          83
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 85,
        "title": "Backend Authentication: Login Endpoint",
        "description": "Implement the backend API endpoint for user login (`/api/auth/login`) using Hono and Supabase authentication.",
        "details": "Create a Hono route `POST /api/auth/login`. Use `zod` for request body validation (email, password). Call `supabase.auth.signInWithPassword({ email, password })`. Handle success (return JWT) and error responses (e.g., invalid credentials).",
        "testStrategy": "Use Postman or `fetch` to `POST /api/auth/login` with valid and invalid credentials for a registered user. Verify a JWT is returned on success and appropriate error messages for failures.",
        "priority": "high",
        "dependencies": [
          83
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 86,
        "title": "Backend Authentication: JWT Validation Middleware",
        "description": "Develop a Hono middleware to validate JWTs from the `Authorization` header for protected API endpoints.",
        "details": "Create a Hono middleware function. Extract the JWT from the `Authorization: Bearer <token>` header. Use `supabase.auth.getUser(token)` to verify the token and retrieve user information. If valid, attach user data to the Hono context (e.g., `c.set('user', user)`). If invalid or missing, return a 401 Unauthorized response. Apply this middleware to protected routes.",
        "testStrategy": "Create a dummy protected endpoint (e.g., `GET /api/protected`). Test accessing it without a token, with an invalid token, and with a valid token. Verify 401 responses for invalid/missing tokens and a successful response with user context for valid tokens.",
        "priority": "high",
        "dependencies": [
          84,
          85
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 87,
        "title": "Frontend Authentication: Signup and Login Forms",
        "description": "Develop the frontend React components for user signup and login forms, utilizing `shadcn/ui`.",
        "details": "Create `SignupForm.tsx` and `LoginForm.tsx` components in `src/components`. Use `shadcn/ui` components (e.g., `Input`, `Button`, `Form`) for styling and structure. Implement form state management (e.g., `useState` or `react-hook-form`). Handle form submission to call the respective backend API endpoints (`/api/auth/signup`, `/api/auth/login`).",
        "testStrategy": "Render the forms in the browser. Test input validation (e.g., empty fields, email format). Verify form submission triggers the correct API calls and handles loading states.",
        "priority": "medium",
        "dependencies": [
          79
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 88,
        "title": "Frontend Authentication: Token Storage and Global State Management",
        "description": "Implement frontend state management for authentication (e.g., `Zustand` or `React Context`) and secure storage of JWTs in `localStorage`.",
        "details": "Choose `Zustand` for global state. Create a store to hold `isAuthenticated` status, `user` object, and `accessToken`. Implement functions to `login` (store token, set auth state), `logout` (clear token, clear auth state). Store the JWT in `localStorage` upon successful login and retrieve it on app initialization. Ensure token is removed on logout.",
        "testStrategy": "Perform a full signup/login flow. Verify `localStorage` contains the token. Refresh the page and confirm the user remains logged in. Perform logout and verify token is removed and state is reset. Test protected routes are inaccessible when logged out.",
        "priority": "high",
        "dependencies": [
          87
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 89,
        "title": "Frontend Authentication: API Request Interceptor",
        "description": "Implement an API request interceptor in the frontend to automatically attach the `Authorization` header with the JWT for all authenticated requests.",
        "details": "Create a utility function or a custom `fetch` wrapper. Before each API call to `/api/*`, retrieve the JWT from `localStorage` (or the Zustand store). If a token exists, add `Authorization: Bearer <token>` to the request headers. This ensures all protected backend calls are authenticated.",
        "testStrategy": "Log in as a user. Make a request to a protected backend endpoint (e.g., `GET /api/protected`). Use browser developer tools to inspect network requests and confirm the `Authorization` header is correctly attached with the valid JWT.",
        "priority": "high",
        "dependencies": [
          88
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 90,
        "title": "Backend API: Story Creation Endpoint",
        "description": "Implement the backend API endpoint for creating new stories (`POST /api/stories`), including `zod` validation for the request body.",
        "details": "Create a Hono route `POST /api/stories`. Apply the authentication middleware (Task 86). Define a `zod` schema for the request body (e.g., `prompt: string`). Validate the incoming request. Initially, just save the `prompt` and `user_id` to the `stories` table. Return a success response with the new story ID.",
        "testStrategy": "As an authenticated user, `POST` to `/api/stories` with valid and invalid prompts. Verify successful creation in Supabase for valid requests and `zod` validation errors for invalid ones. Test unauthenticated access returns 401.",
        "priority": "high",
        "dependencies": [
          83,
          86
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 91,
        "title": "Backend: Integrate Google Gemini API for Story Generation",
        "description": "Integrate the Google Gemini API into the backend to generate story text based on user prompts.",
        "details": "Install the Google Gemini client library (e.g., `@google/generative-ai`). Configure the client with the `GEMINI_API_KEY` from environment variables. Within the `POST /api/stories` endpoint, after validation, call the Gemini API with the user's prompt to generate the `story_text`. Store the generated text in the `stories` table.",
        "testStrategy": "Create a story via the frontend. Verify that the `story_text` field in the Supabase `stories` table is populated with AI-generated content. Test with various prompts to ensure reasonable story generation.",
        "priority": "high",
        "dependencies": [
          82,
          90
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 92,
        "title": "Backend: Integrate Google Gemini API for Illustration Generation (R&D for Consistency)",
        "description": "Integrate the Google Gemini API into the backend to generate illustrations based on the generated story text, focusing on character consistency.",
        "details": "Within the `POST /api/stories` endpoint, after story generation, make another call to the Gemini API (or a specific image generation model if available via Gemini) to generate an image. The prompt for image generation should be derived from the generated story text, focusing on key characters and scenes. Store the resulting `illustration_url` (or base64 if directly returned and then uploaded to storage) in the `stories` table. Research and implement strategies for character consistency (e.g., consistent character descriptions in prompts).",
        "testStrategy": "Generate multiple stories. Verify that `illustration_url` is populated for each. Manually inspect generated images for relevance to the story and observe any patterns or issues with character consistency across different generations.",
        "priority": "high",
        "dependencies": [
          82,
          91
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 93,
        "title": "Backend: Persist Generated Story and Illustration to Supabase",
        "description": "Ensure the generated story text and illustration URLs are correctly persisted to the Supabase `stories` table.",
        "details": "Refine the `POST /api/stories` endpoint to save the `story_text` from Task 91 and `illustration_url` from Task 92 into the `stories` table, along with the `user_id` and initial `is_public` (false) and `published_at` (null).",
        "testStrategy": "Generate a new story through the frontend. Check the Supabase `stories` table to confirm that `story_text`, `illustration_url`, `user_id`, `is_public` (false), and `published_at` (null) are all correctly saved for the new entry.",
        "priority": "high",
        "dependencies": [
          91,
          92
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 94,
        "title": "Frontend: Story Input Form",
        "description": "Develop the frontend React component for users to input their story prompts.",
        "details": "Create a `StoryInputForm.tsx` component. Use `shadcn/ui` components for a text area or input field. Implement state to capture the user's prompt. On submission, call the `POST /api/stories` endpoint, ensuring the `Authorization` header is included by the interceptor.",
        "testStrategy": "Render the input form. Enter a prompt and submit. Verify that the API call is made successfully and the backend receives the prompt. Check for loading indicators and error handling on the frontend.",
        "priority": "medium",
        "dependencies": [
          89
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 95,
        "title": "Frontend: Display Generated Story and Illustration",
        "description": "Create frontend React components to display the generated story text and illustration.",
        "details": "Develop a `StoryDisplay.tsx` component that receives `story_text` and `illustration_url` as props. Use `shadcn/ui` for layout and styling. Display the text clearly and render the image using an `<img>` tag. Implement basic loading and error states.",
        "testStrategy": "After generating a story, verify that the generated text and image are correctly displayed on the frontend. Test with different story lengths and image aspect ratios to ensure proper rendering.",
        "priority": "medium",
        "dependencies": [
          94
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 96,
        "title": "Supabase Schema Update: Public Story Columns",
        "description": "Update the Supabase `stories` table schema to include `is_public` (boolean, default: false) and `published_at` (timestamp) columns.",
        "details": "Execute SQL migration or use Supabase Studio to add `is_public` (type `BOOLEAN`, default `FALSE`) and `published_at` (type `TIMESTAMP WITH TIME ZONE`, nullable) columns to the `stories` table.",
        "testStrategy": "Verify the new columns exist in the `stories` table schema in Supabase Studio. Insert a new record and confirm `is_public` defaults to `false` and `published_at` is `NULL`.",
        "priority": "high",
        "dependencies": [
          83
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 97,
        "title": "Backend API: Publish Story Endpoint",
        "description": "Implement the backend API endpoint (`PATCH /api/stories/:id/publish`) to update a story's `is_public` status and `published_at` timestamp.",
        "details": "Create a Hono route `PATCH /api/stories/:id/publish`. Apply authentication middleware. Validate that the requesting user owns the story (or is an admin). Update the `stories` table: set `is_public` to `true` and `published_at` to `now()` for the specified story ID. Return the updated story data.",
        "testStrategy": "As an authenticated user, `PATCH` to `/api/stories/:id/publish` for a story they own. Verify `is_public` becomes `true` and `published_at` is set in Supabase. Test with a story not owned by the user (expect 403 Forbidden) and with an invalid ID (expect 404 Not Found). Test unauthenticated access (expect 401).",
        "priority": "high",
        "dependencies": [
          86,
          96
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 98,
        "title": "Frontend: 'Publish' Button and Public URL Modal",
        "description": "Add a 'Publish' button to the frontend story detail page and implement a success modal displaying the public URL with a copy button.",
        "details": "On the story detail page, add a button labeled '公開する' (Publish). On click, call `PATCH /api/stories/:id/publish`. Upon success, display a `shadcn/ui` Dialog/Modal. The modal should show the public URL (e.g., `https://<domain>/stories/public/:id`) and include a copy-to-clipboard button. Handle loading and error states.",
        "testStrategy": "Generate a story. Navigate to its detail page. Click 'Publish'. Verify the API call is made, the modal appears with the correct URL, and the copy button functions. Confirm the story's public status is updated in Supabase.",
        "priority": "medium",
        "dependencies": [
          97
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 99,
        "title": "Frontend: Public Story View Page",
        "description": "Create a new frontend route `/stories/public/:id` that displays a specific story and illustration without requiring user authentication.",
        "details": "Configure `React Router` to handle the `/stories/public/:id` route. This route should fetch the story data from the backend (e.g., `GET /api/stories/:id` which needs to be made public or have specific RLS). Use the `StoryDisplay` component (Task 95) to render the content. Ensure no authentication checks are performed on this route.",
        "testStrategy": "Publish a story. Copy its public URL. Open an incognito browser window (not logged in) and navigate to the public URL. Verify the story and illustration are displayed correctly. Test with an ID of an unpublished story (should not be accessible).",
        "priority": "high",
        "dependencies": [
          95
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 100,
        "title": "Supabase RLS: Public and Private Story Access",
        "description": "Implement Supabase Row Level Security (RLS) on the `stories` table to allow public read access for stories where `is_public` is `true`, while maintaining owner-only read access for other stories.",
        "details": "In Supabase Studio, navigate to the `stories` table RLS policies. Create a new `SELECT` policy. Define the `USING` expression to allow access if `is_public = true` OR `auth.uid() = user_id`. This combines the public access rule with the existing owner-only rule.",
        "testStrategy": "1. Logged-in user: Verify they can see their own stories (public or private). 2. Logged-out user: Verify they can only see stories where `is_public` is `true`. Attempt to access a private story as a logged-out user (should fail). 3. Logged-in user: Verify they cannot see other users' private stories.",
        "priority": "high",
        "dependencies": [
          96,
          99
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 101,
        "title": "Frontend: Display Public Status in Story List",
        "description": "Update the frontend story list page to visually indicate which stories are public (e.g., with a 'Public' tag or icon).",
        "details": "Modify the component responsible for displaying the list of user's stories. When fetching story data, include the `is_public` field. Based on this field, render a 'Public' tag, an eye icon, or similar visual indicator next to the story title or on the story card.",
        "testStrategy": "Generate several stories. Publish some and keep others private. Navigate to the story list page. Verify that only the published stories display the 'Public' indicator correctly.",
        "priority": "medium",
        "dependencies": [
          98,
          100
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 102,
        "title": "Backend: Implement Unpublish Story Feature",
        "description": "Implement a new backend API endpoint (e.g., PATCH /api/stories/:id/unpublish) that allows an authenticated story owner to set the 'is_public' flag of a story to false and nullify its 'published_at' timestamp.",
        "details": "Create a new Hono route, for example, PATCH /api/stories/:id/unpublish. Apply the authentication middleware (from Task 86) to protect this endpoint. Extract the story 'id' from the URL parameters and the authenticated 'user_id' from the Hono context. Before performing the update, query the 'stories' table to verify that the story with the given 'id' exists and its 'user_id' matches the authenticated 'user_id'. If the story is not found or the user is not the owner, return an appropriate error response (e.g., 404 Not Found or 403 Forbidden). If authorized, update the 'stories' table for the specified 'id' by setting 'is_public' to 'false' and 'published_at' to 'NULL'. Return a success response (e.g., 200 OK) with the updated story data or a confirmation message.",
        "testStrategy": "1. **Prerequisite:** Ensure a story exists and is owned by a test user. Publish this story using the endpoint from Task 97, verifying 'is_public' is true and 'published_at' is set in Supabase. 2. **Successful Unpublish:** As the authenticated owner of the published story, send a PATCH request to /api/stories/:id/unpublish. Verify the API returns a 200 OK. Check the Supabase 'stories' table for that story ID to confirm 'is_public' is now 'false' and 'published_at' is 'NULL'. 3. **Unauthenticated Access:** Attempt to PATCH to the endpoint without a JWT. Verify a 401 Unauthorized response. 4. **Unauthorized User:** As an authenticated user who does not own the story, attempt to PATCH to the endpoint. Verify a 403 Forbidden response. 5. **Invalid Story ID:** As an authenticated user, attempt to PATCH to the endpoint with a non-existent story ID. Verify a 404 Not Found response. 6. **Already Unpublished Story:** Attempt to unpublish a story that is already 'is_public: false'. Verify the operation completes successfully (idempotent) or returns an appropriate status/message.",
        "status": "done",
        "dependencies": [
          86,
          96,
          97
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 103,
        "title": "Refactor: Unify Story View Endpoint and Frontend",
        "description": "Modify the backend to serve both public and private story data from a single '/stories/:id' endpoint, based on user authentication and ownership. Remove the now-obsolete '/stories/public/:id' route and the corresponding frontend component (PublicStoryPage.tsx). Update StoryDetailPage.tsx to handle both authenticated owner views and public anonymous views.",
        "details": "### Backend Modifications\n1.  **Modify GET /api/stories/:id endpoint:**\n    *   Ensure this endpoint is protected by the authentication middleware (Task 86) but allows unauthenticated access to proceed with limited data.\n    *   Inside the handler, retrieve the story by `id` from the database.\n    *   **Access Logic:**\n        *   If an authenticated user is present (from middleware context):\n            *   If the user's `id` matches the story's `user_id` (owner), return the story data regardless of its `is_public` status.\n            *   If the user is not the owner, check if `is_public` is `true`. If so, return the story. Otherwise, return a 404 Not Found response (to avoid revealing existence of private stories).\n        *   If no authenticated user is present (anonymous access):\n            *   Check if `is_public` is `true`. If so, return the story. Otherwise, return a 404 Not Found response.\n    *   Ensure appropriate HTTP status codes (200 OK, 404 Not Found) are returned.\n2.  **Remove /api/stories/public/:id route:**\n    *   Locate and delete or comment out any existing Hono route definition for `/api/stories/public/:id`.\n\n### Frontend Modifications\n1.  **Remove PublicStoryPage.tsx:**\n    *   Delete the `src/pages/PublicStoryPage.tsx` file (or equivalent).\n    *   Remove any corresponding route definitions in `src/App.tsx` or `src/main.tsx` that point to `PublicStoryPage.tsx`.\n2.  **Update StoryDetailPage.tsx:**\n    *   Modify the data fetching logic within `StoryDetailPage.tsx` to always call the unified `GET /api/stories/:id` endpoint.\n    *   Implement conditional rendering based on the fetched data and the user's authentication status (e.g., display editing options only for owners).\n    *   Handle cases where the story is not found or access is denied (e.g., 404 response from backend) by displaying a user-friendly message (e.g., 'Story not found' or 'You do not have permission to view this story').\n    *   Ensure the component correctly displays public stories for anonymous users and private/public stories for authenticated owners.",
        "testStrategy": "### Backend Testing\n1.  **Setup:** Create two stories: one private (Story A, owned by User X) and one public (Story B, owned by User Y).\n2.  **Test Private Story (Story A) Access via GET /api/stories/:id:**\n    *   **As User X (owner):** Send authenticated GET request. Expected: 200 OK, full story data.\n    *   **As User Z (authenticated, not owner):** Send authenticated GET request. Expected: 404 Not Found.\n    *   **Unauthenticated:** Send GET request. Expected: 404 Not Found.\n3.  **Test Public Story (Story B) Access via GET /api/stories/:id:**\n    *   **As User Y (owner):** Send authenticated GET request. Expected: 200 OK, full story data.\n    *   **As User Z (authenticated, not owner):** Send authenticated GET request. Expected: 200 OK, full story data.\n    *   **Unauthenticated:** Send GET request. Expected: 200 OK, full story data.\n4.  **Verify Removal of Old Route:** Attempt to access `/api/stories/public/:id` for any story. Expected: 404 Not Found or similar error, confirming route removal.\n\n### Frontend Testing\n1.  **Setup:** Ensure the backend tests above pass and stories are set up as described.\n2.  **Test Private Story (Story A) Display:**\n    *   **Login as User X:** Navigate to `/stories/A_ID`. Expected: Story A content displayed correctly, with owner-specific UI elements (if any).\n    *   **Login as User Z:** Navigate to `/stories/A_ID`. Expected: 'Story not found' or 'Access denied' message.\n    *   **Logout (anonymous):** Navigate to `/stories/A_ID`. Expected: 'Story not found' message.\n3.  **Test Public Story (Story B) Display:**\n    *   **Login as User Y:** Navigate to `/stories/B_ID`. Expected: Story B content displayed correctly, with owner-specific UI elements.\n    *   **Login as User Z:** Navigate to `/stories/B_ID`. Expected: Story B content displayed correctly.\n    *   **Logout (anonymous):** Navigate to `/stories/B_ID`. Expected: Story B content displayed correctly.\n4.  **Code Review:** Verify `PublicStoryPage.tsx` file is deleted and no longer referenced in the frontend codebase.",
        "status": "done",
        "dependencies": [
          53,
          86,
          90,
          96,
          97,
          102
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 104,
        "title": "Implement Story Read-Aloud Feature",
        "description": "Implement a story read-aloud feature, including a backend API to generate and store audio using Google Gemini API, and frontend integration with an audio generation button and player on the story detail page.",
        "details": "### Backend Development\n1.  **Database Schema Update:** Add a new `audio_url` column (TEXT type) to the `stories` table to store the URL of the generated audio file.\n2.  **New API Endpoint:** Create a new Hono endpoint, e.g., `POST /api/stories/:id/audio-generate`.\n    *   Apply the authentication middleware (from Task 86) to protect this endpoint, ensuring only the story owner can trigger audio generation.\n    *   Extract the `story_id` from the URL parameters and the `user_id` from the authenticated context.\n    *   Verify that the authenticated `user_id` matches the `user_id` of the story being requested.\n    *   Retrieve the `story_text` for the given `story_id` from the database.\n3.  **Audio Generation:** Utilize the Google Gemini API (or a related Google AI service like Google Cloud Text-to-Speech, accessible via the same Google Cloud project setup as Gemini) to convert the `story_text` into an audio format (e.g., MP3).\n    *   Research and select the most appropriate Google AI model/service for high-quality text-to-speech conversion.\n    *   Handle potential rate limits or long processing times for audio generation.\n4.  **Audio Storage:** Store the generated audio file in Supabase Storage.\n    *   Define a clear naming convention for audio files (e.g., `stories/audio/{story_id}.mp3`).\n    *   Ensure proper access control for the stored audio files (e.g., public read access).\n5.  **Database Update:** After successful generation and storage, update the `audio_url` column in the `stories` table with the public URL of the newly stored audio file.\n\n### Frontend Development (StoryDetailPage.tsx)\n1.  **Conditional UI:** On the `StoryDetailPage.tsx` (unified by Task 103), add a 'Generate Audio' button.\n    *   This button should only be visible to the authenticated user if they are the owner of the story.\n    *   If `story.audio_url` already exists, display an audio player instead of the 'Generate Audio' button.\n2.  **Audio Generation Flow:**\n    *   When the 'Generate Audio' button is clicked, make an API call to the new `POST /api/stories/:id/audio-generate` endpoint.\n    *   Implement a loading state while the audio is being generated.\n    *   Upon successful response, update the story data in the frontend state to include the new `audio_url`.\n3.  **Audio Player:** Implement an HTML5 `<audio>` element to play the generated audio.\n    *   The player should be displayed when `story.audio_url` is available.\n    *   Consider adding basic controls (play/pause, progress bar).\n4.  **Error Handling:** Display user-friendly error messages if audio generation fails (e.g., API error, network issue).\n5.  **User Experience:** Consider adding a confirmation dialog before generating audio, as it might incur costs or take time.\n\n### General Considerations\n*   **Cost Management:** Be mindful of the costs associated with Google AI API calls for audio generation.\n*   **Performance:** Optimize the audio generation process to minimize latency.\n*   **Scalability:** Ensure the storage and serving of audio files can scale with the number of stories.",
        "testStrategy": "### Backend Testing\n1.  **Prerequisite:** Ensure a story exists and is owned by a test user.\n2.  **Successful Audio Generation (Owner):**\n    *   As the authenticated owner of a story, send a `POST` request to `/api/stories/:id/audio-generate`.\n    *   Expected: 200 OK response. Verify that an audio file is created in Supabase Storage (e.g., `stories/audio/{story_id}.mp3`) and the `audio_url` column in the `stories` table for that story is updated with the correct URL.\n    *   Manually download and play the generated audio file to confirm it corresponds to the story text.\n3.  **Unauthorized Access (Non-Owner):**\n    *   As an authenticated user who is *not* the owner of a story, attempt to send a `POST` request to `/api/stories/:id/audio-generate` for that story.\n    *   Expected: 403 Forbidden response.\n4.  **Unauthenticated Access:**\n    *   As an unauthenticated user, attempt to send a `POST` request to `/api/stories/:id/audio-generate`.\n    *   Expected: 401 Unauthorized response.\n5.  **Invalid Story ID:** Send a request with a non-existent story ID. Expected: 404 Not Found.\n\n### Frontend Testing\n1.  **Owner View (No Audio Yet):**\n    *   Log in as a story owner. Navigate to one of their story detail pages that does not yet have an `audio_url`.\n    *   Verify that the 'Generate Audio' button is visible.\n    *   Click the 'Generate Audio' button. Observe the loading state. Verify that upon completion, an audio player appears and the generated audio can be played.\n2.  **Owner View (Audio Exists):**\n    *   Log in as a story owner. Navigate to a story detail page that already has an `audio_url`.\n    *   Verify that the 'Generate Audio' button is *not* visible, and an audio player is displayed instead. Confirm the audio can be played.\n3.  **Non-Owner/Public View:**\n    *   Log in as a different user (not the owner) or log out completely. Navigate to a public story detail page.\n    *   Verify that the 'Generate Audio' button is *not* visible.\n    *   If the story has an `audio_url`, verify that the audio player is displayed and the audio can be played by non-owners/public users.\n4.  **Error Handling UI:** Simulate a backend error during audio generation (e.g., by temporarily disabling the Gemini API key). Verify that an appropriate error message is displayed on the frontend.",
        "status": "pending",
        "dependencies": [
          59,
          86,
          103
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Database Schema and Initial API Endpoint",
            "description": "Update the `stories` table with a new `audio_url` column and create the skeleton for the `POST /api/stories/:id/audio-generate` endpoint. This includes setting up authentication middleware, extracting parameters, and implementing authorization checks to ensure only the story owner can trigger audio generation.",
            "dependencies": [],
            "details": "1.  **Database Schema Update:** Add a `audio_url` column (TEXT type) to the `stories` table. Ensure migrations are handled if applicable. 2.  **New API Endpoint:** Create a Hono endpoint `POST /api/stories/:id/audio-generate`. Apply authentication middleware (from Task 86). Extract `story_id` from URL and `user_id` from authenticated context. Implement logic to verify `user_id` matches the `user_id` of the story. Retrieve `story_text` from the database. For now, return a placeholder success response.",
            "status": "done",
            "testStrategy": "Manually test the endpoint using an API client (e.g., Postman). Verify that authenticated requests from the story owner succeed, while requests from other users or unauthenticated requests fail with appropriate error messages. Confirm `story_text` retrieval."
          },
          {
            "id": 2,
            "title": "Implement Backend Audio Generation and Storage Logic",
            "description": "Integrate Google AI (Gemini API or Google Cloud Text-to-Speech) into the `POST /api/stories/:id/audio-generate` endpoint to convert story text into audio. Store the generated audio file in Supabase Storage and update the `stories` table with its public URL.",
            "dependencies": [
              1
            ],
            "details": "1.  **Audio Generation:** Within the `POST /api/stories/:id/audio-generate` endpoint, utilize the Google Gemini API (or Google Cloud Text-to-Speech) to convert the retrieved `story_text` into an audio format (e.g., MP3). Research and select the most appropriate model for quality. 2.  **Audio Storage:** Store the generated audio file in Supabase Storage. Define a naming convention (e.g., `stories/audio/{story_id}.mp3`) and ensure public read access. 3.  **Database Update:** After successful generation and storage, update the `audio_url` column in the `stories` table with the public URL of the newly stored audio file.",
            "status": "pending",
            "testStrategy": "Use an API client to call the endpoint. Verify that an audio file is created in Supabase Storage with the correct naming and content. Check that the `audio_url` in the database for the corresponding story is updated and points to the correct, publicly accessible URL. Test with different story lengths."
          },
          {
            "id": 3,
            "title": "Create Reusable Audio Player Component",
            "description": "Develop a dedicated, reusable React component for playing audio files, leveraging the HTML5 `<audio>` element. This component should be flexible enough to accept an audio URL as a prop.",
            "dependencies": [],
            "details": "Create a new React component (e.g., `AudioPlayer.tsx`). This component should accept an `audioUrl` prop (string). Implement an HTML5 `<audio>` element within the component, setting its `src` attribute to `audioUrl` and including the `controls` attribute for basic playback controls. Consider minimal styling for integration.",
            "status": "pending",
            "testStrategy": "Create a temporary test page or a Storybook entry to render the `AudioPlayer` component. Provide a sample audio URL (e.g., a public MP3 file) and verify that the player renders correctly and audio playback functions as expected."
          },
          {
            "id": 4,
            "title": "Implement Frontend Audio Generation Button and API Integration",
            "description": "Add a 'Generate Audio' button to `StoryDetailPage.tsx`. This button should be conditionally visible only to the story owner and trigger an API call to the backend audio generation endpoint. Implement loading states during the generation process.",
            "dependencies": [
              2
            ],
            "details": "1.  **Conditional UI:** In `StoryDetailPage.tsx`, add a 'Generate Audio' button. Implement logic to display this button only if the authenticated user is the owner of the story AND `story.audio_url` is not yet present. 2.  **Audio Generation Flow:** When the button is clicked, make an API call to the `POST /api/stories/:id/audio-generate` endpoint. Implement a loading state (e.g., disable button, show a spinner) while the request is in progress. Upon successful response, update the local story data in the frontend state to include the new `audio_url` received from the backend.",
            "status": "pending",
            "testStrategy": "Log in as a story owner for a story without audio. Verify the 'Generate Audio' button is visible. Click the button and observe the loading state. Check network requests to confirm the API call. After success, verify the `story.audio_url` state updates in the frontend. Log in as a non-owner or for a story with existing audio to ensure the button is not visible."
          },
          {
            "id": 5,
            "title": "Integrate Audio Player and Refine Story Detail Page UI",
            "description": "Integrate the `AudioPlayer` component into `StoryDetailPage.tsx`. Implement logic to display the audio player when `story.audio_url` is available, instead of the generation button. Add comprehensive error handling and user experience improvements like a confirmation dialog.",
            "dependencies": [
              3,
              4
            ],
            "details": "1.  **Audio Player Integration:** In `StoryDetailPage.tsx`, conditionally render the `AudioPlayer` component (passing `story.audio_url` as a prop) when `story.audio_url` is present. This should replace the 'Generate Audio' button. 2.  **Error Handling:** Implement user-friendly error messages (e.g., toast notifications) if the audio generation API call fails. 3.  **User Experience:** Add a confirmation dialog before triggering the audio generation process, informing the user about potential costs or processing time.",
            "status": "pending",
            "testStrategy": "Test the full flow: 1. Story without audio: 'Generate Audio' button visible, click triggers confirmation, then generation, then player appears. 2. Story with existing audio: `AudioPlayer` component is immediately visible and playable. 3. Simulate API errors during generation to verify error messages are displayed. 4. Verify confirmation dialog functionality."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-06-27T15:43:05.337Z",
      "updated": "2025-07-02T13:13:40.264Z",
      "description": "Tasks for master context"
    }
  }
}