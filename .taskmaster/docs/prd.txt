# 開発チーム向け技術指示書：ものがたりWeavers (v2 - MVP)

## 1. 概要

本ドキュメントは、Webアプリケーション「ものがたりWeavers」の開発チーム（AIアシスタントを含む）向けに、システムアーキテクチャ、使用技術スタック、および各機能の実装方針を定めるものです。
**正典は `monogatari_weavers_02.md` であり、この指示書はそれに準拠します。**

## 2. システムアーキテクチャ概要

本システムは、フロントエンドとバックエンドを明確に分離した**「静的SPA + API」アーキテクチャ**を採用します。

```mermaid
graph TD
    subgraph "ユーザーのブラウザ"
        U["Client (React App)"]
    end

    subgraph "Cloudflareネットワーク"
        subgraph "Cloudflare Pages (静的ホスティング)"
            F["React SPA<br/>(index.html, JS, CSS)"]
        end
        subgraph "Cloudflare Pages Functions (サーバーレスAPI)"
            A["Hono APIサーバー<br/>リクエストパス: /api/*"]
        end
    end

    subgraph "外部サービス"
        S[Supabase<br>DB, 認証]
        G[Google Gemini API<br>AI]
    end

    U -- "1. ページアクセス (例: /login)" --> F;
    F -- "2. Reactアプリをブラウザに送信" --> U;
    U -- "3. Reactアプリがマウント・実行される" --> U;
    U -- "4. APIリクエスト (例: POST /api/login)" --> A;
    A -- "5. APIロジック実行" --> A;
    A -- "6. 必要に応じて外部サービスと通信" --> S;
    A -- "6. 必要に応じて外部サービスと通信" --> G;
    S -- "7. 結果を返す" --> A;
    G -- "7. 結果を返す" --> A;
    A -- "8. APIレスポンスを返す" --> U;
```

*   **フロントエンド**: Viteでビルドされた純粋なReact SPAです。Cloudflare Pagesの静的ホスティング機能で配信されます。
*   **バックエンド**: Honoで構築されたAPIサーバーです。Cloudflare Pages Functionsとしてデプロイされ、`/api/*` へのリクエストを処理します。
*   **責務の分離**: この構成により、フロントエンドはUIの構築と状態管理に、バックエンドはビジネスロジックと外部サービス連携にそれぞれ専念でき、複雑さを低減します。

## 3. 技術スタック

*   **フロントエンド**: **React (TypeScript)**
    *   **ビルドツール**: **Vite**
    *   **ルーティング**: **React Router**
    *   **状態管理**: **Zustand** または **React Context** （必要に応じて導入）
    *   **UIコンポーネント**: **shadcn/ui** （予定）
*   **バックエンド**: **Hono**
    *   Cloudflare Pages Functions上で動作する、軽量かつ高速なAPIフレームワーク。
*   **データベース & BaaS**: **Supabase**
    *   ユーザー情報、物語データ等の永続化、およびユーザー認証に使用。
*   **AI**: **Google Gemini API**
    *   物語生成とイラスト生成の両方に使用。

## 4. プロジェクト構造

```
/
├── functions/      # バックエンド (Hono API)
│   └── api/
│       └── [[path]].ts # /api/* を処理するエントリーポイント
├── public/         # Viteが扱う静的アセット
├── src/            # フロントエンド (React SPA)
│   ├── assets/
│   ├── components/
│   ├── lib/
│   ├── pages/
│   └── main.tsx    # フロントエンドのエントリーポイント
├── .dev.vars       # バックエンド用のローカル環境変数
├── .env            # フロントエンド用のローカル環境変数
├── index.html      # SPAのルートHTML
├── package.json
└── vite.config.ts
```

## 5. 開発とデプロイ

*   **開発**: `wrangler` と Vite の開発サーバーを `concurrently` などで同時に実行します。`vite.config.ts` のプロキシ設定により、フロントエンドからバックエンドAPIへのリクエストを透過的に転送します。
*   **デプロイ**: `git push` をトリガーに、Cloudflare Pagesが自動でフロントエンドのビルドとバックエンドFunctionsのデプロイを実行します。
*   **環境変数**:
    *   **ローカル**: フロントエンドは `.env` (`VITE_`プレフィックス)、バックエンドは `.dev.vars` を使用。
    *   **本番**: Cloudflare Pagesのコンソールからフロントエンド用とバックエンド用の環境変数をそれぞれ設定。

## 6. 主要機能の実装方針

### 6.1. 認証フロー
1.  **サインアップ/ログイン**: フロントエンドのフォームから `/api/auth/signup` や `/api/auth/login` にリクエスト。
2.  **トークン処理**: バックエンドはSupabaseと連携して認証を行い、成功すればJWT（アクセストークン）をフロントエンドに返す。
3.  **状態管理**: フロントエンドは受け取ったトークンをセキュアなストレージ（`localStorage`等）に保存し、認証状態をグローバルに管理する。APIリクエスト時は常に `Authorization` ヘッダーにトークンを付与する。
4.  **セッション検証**: バックエンドは保護されたAPIエンドポイントで、リクエストヘッダーのトークンを検証するミドルウェアを実装する。

### 6.2. 物語・イラスト生成フロー
1.  **リクエスト**: 認証済みのユーザーがフロントエンドから物語の元となるテキストを送信 (`POST /api/stories`)。
2.  **バックエンド処理**:
    *   リクエストボディを `zod` でバリデーション。
    *   `Gemini API` を呼び出して物語を生成。
    *   生成された物語を基に、再度 `Gemini API` を呼び出してイラストを生成（キャラクターの一貫性は最重要R&D項目）。
    *   生成物とユーザーIDを `Supabase` に保存。
    *   生成物のURLなどをフロントエンドに返す。
3.  **表示**: フロントエンドは受け取ったデータを表示する。

---

この指示書を基に、開発を進めてください。

### 6.3. 物語の公開機能
1.  **ステータス変更**:
    *   `stories` テーブルに `is_public` (boolean, default: false) カラムと `published_at` (timestamp) カラムを追加する。
    *   フロントエンドの物語詳細ページに「公開する」ボタンを設置する。
    *   ボタンクリックで `PATCH /api/stories/:id/publish` のようなAPIを呼び出し、`is_public` を `true` に更新する。
2.  **公開モーダル**:
    *   公開が成功したら、フロントエンドでモーダルを表示する。
    *   モーダルには、公開された物語のURL（例: `https://<domain>/stories/public/:id`）が表示され、コピーボタンを設置する。
3.  **公開ページの作成**:
    *   `/stories/public/:id` というルートをフロントエンドに追加する。このページは認証を必要としない。
    *   このページでは、指定されたIDの物語とイラストを表示する。
4.  **一覧での表示**:
    *   物語一覧ページで、公開されている物語には「Public」などのタグやアイコンを表示する。
5.  **アクセス制御 (Supabase RLS)**:
    *   `is_public = true` の物語は、認証されていないユーザーでも読み取り可能にする必要がある。
    *   `select` 操作に対する新しいRLSポリシーを `stories` テーブルに追加する。「`is_public`が`true`の場合は誰でも読み取れる」というルールを定義する。既存の「自分のデータのみ読み取れる」ルールと組み合わせる。 